<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>对JAVA注解（Annotation）的理解</title>
    <link href="/2020/10/30/%E5%AF%B9JAVA%E6%B3%A8%E8%A7%A3%EF%BC%88Annotation%EF%BC%89%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2020/10/30/%E5%AF%B9JAVA%E6%B3%A8%E8%A7%A3%EF%BC%88Annotation%EF%BC%89%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Java注解-Annotation"><a href="#Java注解-Annotation" class="headerlink" title="Java注解(Annotation)"></a>Java注解(Annotation)</h1><p><font color=#999AAA >首先得明白什么是注解？<br>注解：解释词句的文字；（中文解释）<br>Annotation: a comment or instruction.(英文注释)<br>说白了就是让别人看到了就知道啥意思，只不过这里的“别人”是计算机程序而已</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以<strong>通过反射获取标注内容</strong>。在编译器生成类文件时，<strong>标注可以被嵌入到字节码</strong>中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 当然它也支持自定义 Java 标注。<br><img src="https://img-blog.csdnimg.cn/img_convert/d3821205e0bad70872dd1c060aa4dca0.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>忽略它的那么多注释，化繁为简，它就只是个普普通通的interface接口而已；</p><h4 id="接口的特性"><a href="#接口的特性" class="headerlink" title="接口的特性"></a>接口的特性</h4><ul><li>接口中的方法可以有参数列表和返回类型，但不能有任何方法体</li><li>接口中可以包含字段，但是会被隐式的声明为 static 和 final</li><li>接口中的字段只是被存储在该接口的静态存储区域内，而不属于该接口</li><li>接口中的方法可以被声明为 public 或不声明，但结果都会按照 public 类型处理</li><li>当实现一个接口时，需要将被定义的方法声明为 public 类型的，否则为默认访问类型， Java 编译器不允许这种情况</li><li>如果没有实现接口中所有方法，那么创建的仍然是一个接口</li><li>扩展一个接口来生成新的接口应使用关键字 extends ，实现一个接口使用 implements</li><li>接口中的方法是抽象方法(abstract)，不能是静态方法(static).接口的所有方法都是抽象的，而抽象方法是没有static，有static的方法是不能override的，所以这样定义接口才有意义<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><font color=#999AAA >就像26个英文字母，组成了不同的单词，拥有不同的意思；<br>注解则是四个元注解和注解的类型（ElementType）或生命周期策略（RetentionPolicy）组成各种不同含义的注解；<br><br></li></ul><p><strong>For example:</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/b5a40ee34589e5de404c7e90f4d09f4a.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><strong>@Target</strong></p><ul><li><strong>Indicates the contexts in which an annotation type is applicable.</strong></li><li><strong>提示上下文哪个注解类型是适用的。</strong></li></ul><p><strong>@Inherited</strong></p><ul><li><strong>Indicates that an annotation type is automatically inherited.</strong></li><li><strong>注解将自动继承。</strong></li></ul><p><strong>@Documented</strong></p><ul><li><strong>Indicates that annotations with a type are to be documented by javadoc and similar tools by default.</strong></li><li><strong>注解将由javadoc和类似的工具默认记录。</strong></li></ul><p><strong>@Retention</strong></p><ul><li><strong>Indicates how long annotations with the annotated type are to be retained.</strong></li><li><strong>提示带注解类型的注解将保留多长时间。</strong></li></ul><h2 id="ElementType"><a href="#ElementType" class="headerlink" title="ElementType"></a>ElementType</h2><blockquote><p>The constants of this enumerated type provide a simple classification of the syntactic locations where annotations may appear in a Java program. These constants are used in {@link Target java.lang.annotation.Target} meta-annotations to specify where it is legal to write annotations of a  given type.</p></blockquote><blockquote><p>这些枚举类型的常量给可能出现在Java程序中的注解提供一个简单的语法定位的分类（简化：这些常量给注解提供了一个分类）；<br>这些常量用在元注解（java.lang.annotation.Target）中来指定在哪里编写这些给定类型的注解是合法的。</p></blockquote><ul><li><strong>ElementType.TYPE：可用于类、接口（包括注解类型（@interface））或者枚举类型定义处</strong></li><li><strong>ElementType.FIELD：可用于变量（包括枚举）定义处</strong></li><li><strong>ElementType.METHOD：可用于方法定义处</strong></li><li><strong>ElementType.PARAMETER：可用于形式参数定义处</strong></li><li><strong>ElementType.CONSTRUCTOR：可用于构造方法定义处</strong></li><li><strong>ElementType.LOCAL_VARIABLE：可用于本地变量定义处</strong></li><li><strong>ElementType.ANNOTATION_TYPE：可用于注解定义处</strong></li><li><strong>ElementType.PACKAGE：可用于包定义处</strong></li></ul><h2 id="RetentionPolicy"><a href="#RetentionPolicy" class="headerlink" title="RetentionPolicy"></a>RetentionPolicy</h2><blockquote><p>Annotation retention policy.  The constants of this enumerated type describe the various policies for retaining annotations.  They are used in conjunction with the {@link Retention} meta-annotation type to specify how long annotations are to be retained.</p></blockquote><blockquote><p>注解的生命周期策略；这些枚举类型的常量用于描述各种注解的生命周期策略；它们和元注解类型被用来指定注解将存活多久。</p></blockquote><ul><li><strong>RetentionPolicy.SOURCE：当前注解编译期可见，不会写入 class 文件</strong></li><li><strong>RetentionPolicy.CLASS：类加载阶段丢弃，会写入 class 文件</strong></li><li><strong>RetentionPolicy.RUNTIME：永久保存，可以反射获取</strong></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>很多问题都可以化繁为简，把复杂难以理解的东西变成同意理解的东西，回到它最初的本质。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Annotation，注解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Oracle 11g 服务介绍</title>
    <link href="/2020/05/15/Oracle%2011g%20%E6%9C%8D%E5%8A%A1%E4%BB%8B%E7%BB%8D/"/>
    <url>/2020/05/15/Oracle%2011g%20%E6%9C%8D%E5%8A%A1%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="Oracle的七个服务"><a href="#Oracle的七个服务" class="headerlink" title="Oracle的七个服务"></a>Oracle的七个服务</h2><p>安装完 Oracle 11g后会出现以下七个服务，分别是：</p><ul><li>Oracle ORCL VSS Writer Service</li><li>OracleDBConsoleorcl</li><li>OracleJobSchedulerORCL</li><li>OracleMTSRecoveryService</li><li>OracleOraDb11g_home1ClrAgent</li><li>OracleOraDb11g_home1TNSListener</li><li>OracleServiceORCL<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9mdW5nbm90bC1pbWcub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS9PcmFjbGUlMjAxMWclMjAlRTQlQjglODMlRTUlQTQlQTclRTYlOUMlOEQlRTUlOEElQTElRTglQUYlQTYlRTclQkIlODYlRTQlQkIlOEIlRTclQkIlOEQvT3JhY2xlJUU2JTlDJThEJUU1JThBJUExLnBuZw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="在这里插入图片描述"></li></ul><h3 id="Oracle-ORCL-VSS-Writer-Service（Oracle卷映射拷贝写入服务）"><a href="#Oracle-ORCL-VSS-Writer-Service（Oracle卷映射拷贝写入服务）" class="headerlink" title="Oracle ORCL VSS Writer Service（Oracle卷映射拷贝写入服务）"></a>Oracle ORCL VSS Writer Service（Oracle卷映射拷贝写入服务）</h3><p>Oracle ORCL VSS Writer Service（Oracle卷映射拷贝写入服务），VSS（Volume Shadow Copy Service）能够让存储基础设备（比如磁盘，阵列等）创建高保真的时间点映像，即映射拷贝（shadow copy）。它可以在多卷戒者单个卷上创建映射拷贝，同时不会影响到系统的系统性能。<strong>（非必须启动）</strong></p><h3 id="OracleDBConsoleorcl（Oracle数据库控制台服务）"><a href="#OracleDBConsoleorcl（Oracle数据库控制台服务）" class="headerlink" title="OracleDBConsoleorcl（Oracle数据库控制台服务）"></a>OracleDBConsoleorcl（Oracle数据库控制台服务）</h3><p>Oracle数据库控制台服务，orcl是Oracle的实例标识，默认的实例为orcl。在运行Enterprise Manager（企业管理器OEM）的时候，需要开启这个服务。<strong>（非必须启动）</strong></p><h3 id="OracleJobSchedulerORCL（Oracle作业调度服务）"><a href="#OracleJobSchedulerORCL（Oracle作业调度服务）" class="headerlink" title="OracleJobSchedulerORCL（Oracle作业调度服务）"></a>OracleJobSchedulerORCL（Oracle作业调度服务）</h3><p>Oracle作业调度（定时器）服务，ORCL是Oracle实例标识。<strong>（非必须启动）</strong></p><h3 id="OracleMTSRecoveryService"><a href="#OracleMTSRecoveryService" class="headerlink" title="OracleMTSRecoveryService"></a>OracleMTSRecoveryService</h3><p>服务端控制。该服务允许数据库充当一个微软事务服务器MTS、COM/COM+对象和分布式环境下的事务的资源管理器。<strong>（非必须启动）</strong></p><h3 id="OracleOraDb11g-home1ClrAgent"><a href="#OracleOraDb11g-home1ClrAgent" class="headerlink" title="OracleOraDb11g_home1ClrAgent"></a>OracleOraDb11g_home1ClrAgent</h3><p>Oracle数据库.NET扩展服务的一部分。<strong>（非必须启动）</strong></p><h3 id="OracleOraDb11g-home1TNSListener"><a href="#OracleOraDb11g-home1TNSListener" class="headerlink" title="OracleOraDb11g_home1TNSListener"></a>OracleOraDb11g_home1TNSListener</h3><p>监听器服务，服务只有在数据库需要远程访问的时候才需要。<strong>（必须启动）</strong></p><h3 id="OracleServiceORCL"><a href="#OracleServiceORCL" class="headerlink" title="OracleServiceORCL"></a>OracleServiceORCL</h3><p>数据库服务(数据库实例)，是Oracle核心服务该服务，是数据库启动的基础， 只有该服务启动，Oracle数据库才能正常启动。<strong>(必须启动)</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Oracle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单聊聊HashMap和红黑树</title>
    <link href="/2020/05/10/%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8AHashMap%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <url>/2020/05/10/%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8AHashMap%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h3><p>HashMap在JDK1.2时加入，一步步发展到JDK1.6，此时HashMap已经趋于成熟。<br>Java为数据结构中的映射定义了一个接口 java.util.Map，此接口主要有4个常用的实现类，分别是<strong>HashMap</strong>、<strong>HashTable</strong>、<strong>LinkedHashMap</strong>和<strong>TreeMap</strong>,类继承关系如下：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9mdW5nbm90bC1pbWcub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS8lRTglODElOEElRTglODElOEFIYXNoTWFwL0hhc2hNYXAlRTclQkIlOTMlRTYlOUUlODQucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="几个类的特点"><a href="#几个类的特点" class="headerlink" title="几个类的特点"></a>几个类的特点</h3><ul><li><strong>HashMap</strong>：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</li><li><strong>Hashtable</strong>：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，键值都不可为null，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</li><li><strong>LinkedHashMap</strong>：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</li><li><strong>TreeMap</strong>：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</li></ul><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>在JDK1.8以前，HashMap中的数据都是以<strong>数组</strong>+<strong>链表</strong>的方式存储；<br>在JDK1.8，HashMap则加入了红黑树，以<strong>数组</strong>+<strong>链表</strong>+<strong>红黑树</strong>的方式存储；<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9mdW5nbm90bC1pbWcub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS8lRTglODElOEElRTglODElOEFIYXNoTWFwL0hhc2hNYXAlRTUlQUQlOTglRTUlODIlQTglRTclQkIlOTMlRTYlOUUlODQucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>说起红黑树，我们就要说到树，那么，什么是树呢？<br><strong>树是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。</strong></p><p><strong><em>树有以下特点</em></strong>：</p><ul><li>每个节点都只有有限个子节点或无子节点；</li><li>没有父节点的节点称为根节点；</li><li>每一个非根节点有且只有一个父节点；</li><li>除了根节点外，每个子节点可以分为多个不相交的子树；</li><li>树里面没有环路(cycle)</li></ul><p>也就是说，树必须满足以上所有特点。</p><p>还有很多其他树，如二叉搜索树、平衡二叉搜索树（AVL树）、红黑树，这里就简单介绍下红黑树</p><p><strong>红黑树是一种自平衡二叉查找树，1972年由Rudof Bayer发明，它与AVL树类似，都在插入和删除操作时能通过旋转操作保持二叉查找树的平衡，以便能获得高效的查找性能。它可以在O(logn)时间内做查找，插入和删除等操作。</strong></p><p>特点：</p><ul><li>节点是红色或者黑色；</li><li>根节点是黑色；</li><li>每个叶节点都是黑色；</li><li>每个红节点的两个子节点都为黑色；</li><li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点；</li><li>最长路径不超过最短路径的2倍。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>HashMap，红黑树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式六大原则之单一职责原则</title>
    <link href="/2020/04/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E4%B9%8B%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/"/>
    <url>/2020/04/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E4%B9%8B%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h2 id="单一职责原则-SRP-Single-Responsibility-Principle"><a href="#单一职责原则-SRP-Single-Responsibility-Principle" class="headerlink" title="单一职责原则(SRP (Single Responsibility Principle))"></a>单一职责原则(SRP (Single Responsibility Principle))</h2><h3 id="单一职责原则定义："><a href="#单一职责原则定义：" class="headerlink" title="单一职责原则定义："></a>单一职责原则定义：</h3><p><strong>应该有且仅有一个原因引起类的变更</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9mdW5nbm90bC1pbWcub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS8lRTglQUUlQkUlRTglQUUlQTElRTYlQTglQTElRTUlQkMlOEYvJUU1JThEJTk1JUU0JUI4JTgwJUU4JTgxJThDJUU4JUI0JUEzXyVFNyU5NCVBOCVFNiU4OCVCNyVFNCVCRiVBMSVFNiU4MSVBRiVFNyVCMSVCQiVFNSU5QiVCRS5wbmc?x-oss-process=image/format,png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>很简单的一个类图，很容易可以看出问题所在，用户的属性和行为没有分开；<br>应该用户的信息抽取成一个<strong>业务对象接口</strong>，行为抽取成一个<strong>业务逻辑接口</strong></p></blockquote><p>修改后：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9mdW5nbm90bC1pbWcub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS8lRTglQUUlQkUlRTglQUUlQTElRTYlQTglQTElRTUlQkMlOEYvJUU4JTgxJThDJUU4JUI0JUEzJUU1JTg4JTkyJUU1JTg4JTg2JUU1JTkwJThFJUU3JUIxJUJCJUU1JTlCJUJFLnBuZw?x-oss-process=image/format,png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><ul><li>重新拆封成两个接口，IUserBO负责用户的属性，简单地说，IUserBO的职责就是收集和反馈用户的属性信息；</li><li>IUserBiz负责用户的行为，完成用户信息的维护和变更。</li></ul><p>回到单一职责的定义：应该有且只有一个原因引起类的变更，这里就是把一个接口分成两个接口，依赖了单一职责原则。</p><h3 id="单一职责的思考"><a href="#单一职责的思考" class="headerlink" title="单一职责的思考"></a>单一职责的思考</h3><p><strong>但是问题来了，一个职责一个接口，但问题是“职责”没有一个量化的标准，一个类到底要负责那些职责？这些职责该怎么细化？细化后是否都要有一个接口或类？</strong></p><blockquote><p>单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可度量的，因项目而异，因环境而异。</p></blockquote><h3 id="单一职责的优点"><a href="#单一职责的优点" class="headerlink" title="单一职责的优点"></a>单一职责的优点</h3><ul><li>类的复杂性降低，实现什么职责都有清晰明确的定义；</li><li>可读性提高，复杂性降低，那当然可读性提高了；</li><li>可维护性提高，可读性提高，那当然更容易维护了；</li><li>变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式、单一职责原则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>真正解决Could not transfer artifact org.springframework.boot:spring-boot-starter-parent:pom</title>
    <link href="/2020/02/24/%E7%9C%9F%E6%AD%A3%E8%A7%A3%E5%86%B3Could%20not%20transfer%20artifact%20org.springframework.boot_spring-boot-starter-parent_pom/"/>
    <url>/2020/02/24/%E7%9C%9F%E6%AD%A3%E8%A7%A3%E5%86%B3Could%20not%20transfer%20artifact%20org.springframework.boot_spring-boot-starter-parent_pom/</url>
    
    <content type="html"><![CDATA[<h1 id="解决新建springboot项目时包导不进来的问题"><a href="#解决新建springboot项目时包导不进来的问题" class="headerlink" title="解决新建springboot项目时包导不进来的问题"></a>解决新建springboot项目时包导不进来的问题</h1><h2 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h2><ul><li><p>新建一个springboot项目</p></li><li><p>此时maven的setting配置文件配置的阿里云的源</p></li><li><p>发现很多包导不进来,于是reimport,没有效果</p></li><li><p>于是执行clean命令</p></li><li><p>报错</p><blockquote><p>Could not transfer artifact org.springframework.boot:spring-boot-starter-parent:pom:2.2.4.RELEASE from/to alimaven (<a href="https://maven.aliyun.com/repository/central" target="_blank" rel="noopener">https://maven.aliyun.com/repository/central</a>): PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target</p></blockquote></li><li><p>进入报错的网站查找springbootRELEASE2.2.4的包(<a href="https://maven.aliyun.com/repository/central" target="_blank" rel="noopener">https://maven.aliyun.com/repository/central</a>)<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9mdW5nbm90bC1pbWcub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS9zcHJpbmdib290X3N0YXJ0dXAvc3ByaW5nYm9vdF9SRUxFQVNFLmpwZw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></li><li><p>发现阿里云还没有2.2.4的包,于是将springboot的版本改成2.1.7<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9mdW5nbm90bC1pbWcub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS9zcHJpbmdib290X3N0YXJ0dXAvc3ByaW5nYm9vdFZlcnNpb24uanBn?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></li><li><p>还是报错</p></li><li><p>查看报错信息的后半部分</p><blockquote><p>( sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target)<br>无法找到有效的证书</p></blockquote></li><li><p>找到问题所在</p><h2 id="解决问题-两种方法"><a href="#解决问题-两种方法" class="headerlink" title="解决问题(两种方法)"></a>解决问题(两种方法)</h2><h3 id="第一种方法-在执行maven命令时忽略证书检查"><a href="#第一种方法-在执行maven命令时忽略证书检查" class="headerlink" title="第一种方法:在执行maven命令时忽略证书检查"></a>第一种方法:在执行maven命令时忽略证书检查</h3></li><li><p>在新建maven工程时,会自执行maven的各种命令</p></li><li><p>在此处设置忽略证书检查<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9mdW5nbm90bC1pbWcub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS9zcHJpbmdib290X3N0YXJ0dXAvZm9yY2VTb2x1dGlvbi5qcGc?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></li><li><p>命令如下</p><pre><code>Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true</code></pre></li></ul><h3 id="第二种方法-手动导入证书"><a href="#第二种方法-手动导入证书" class="headerlink" title="第二种方法:手动导入证书"></a>第二种方法:手动导入证书</h3><ul><li>确保maven中setting文件中的阿里源配置正确 (注意url中协议为https!)</li></ul><pre><code> &lt;mirror&gt;    &lt;id&gt;nexus-aliyun&lt;/id&gt;    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;    &lt;name&gt;Nexus aliyun&lt;/name&gt;    &lt;url&gt;https://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt;</code></pre><ul><li>将阿里镜像库的证书加到信任证书库里面</li><li>打开上面阿里源的网址</li><li><a href="https://maven.aliyun.com/nexus/content/groups/public或https://maven.aliyun.com/repository/central都是一样的" target="_blank" rel="noopener">https://maven.aliyun.com/nexus/content/groups/public或https://maven.aliyun.com/repository/central都是一样的</a></li><li>通过chrome浏览器下载证书到本地<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9mdW5nbm90bC1pbWcub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS9zcHJpbmdib290X3N0YXJ0dXAvY2VydGlmaWNhdGUuanBn?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="在这里插入图片描述"></li><li>一路next,将文件命名为ali_maven,后缀默认为.cer,保存到D盘根目录</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9mdW5nbm90bC1pbWcub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS9zcHJpbmdib290X3N0YXJ0dXAvZG93bmxvYWQuanBn?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><ul><li>通过证书添加到java信任证书库<blockquote><p>cacerts包含了很多CA证书，位置在Java的安装目录：如: C:\Program Files\Java\jre1.8.0_171\lib\security\carcerts</p></blockquote></li><li>以管理员身份打开命令提示符(cmd)</li><li>进入carcerts所在文件目录</li><li>执行命令<strong>keytool -import -alias cacerts -keystore cacerts -file d:\ali_maven.cer</strong></li><li>默认密钥库口令:<strong>changeit</strong></li><li>是否信任此证书?[否]: <strong><em>Y</em></strong></li><li>显示<strong>证书已添加到密钥库中</strong>即表示添加成功</li><li>回到项目中重新clean,compile,解决</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是非常坑人的地方,没有正确的解决问题会让人十分抓狂<br>希望踩过的坑及时将它填上</p>]]></content>
    
    
    
    <tags>
      
      <tag>springboot</tag>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>桶排序之计数排序与基数排序</title>
    <link href="/2020/01/27/%E6%A1%B6%E6%8E%92%E5%BA%8F%E4%B9%8B%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/01/27/%E6%A1%B6%E6%8E%92%E5%BA%8F%E4%B9%8B%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="桶排序之计数排序和基数排序"><a href="#桶排序之计数排序和基数排序" class="headerlink" title="桶排序之计数排序和基数排序"></a>桶排序之计数排序和基数排序</h1><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><blockquote><p>一种常见的排序算法,工作原理是将数组分到有限数量的桶子里,每个桶子再个别进行排序(会使用递归的方式继续使用桶排序进行排序或者使用其他的排序算法).</p></blockquote><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序是桶排序的一种特殊情况<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9mdW5nbm90bC1pbWcub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS8lRTYlQTElQjYlRTYlOEUlOTIlRTUlQkElOEYvQ291bnRTb3J0LmdpZg" srcset="/img/loading.gif" alt="计数排序"></p><ul><li>从图中可以看出,待排序数字在[1,9]范围内;</li><li>创建9个空桶,将待排序数字分别放在对应的桶中;</li><li>再依次将桶中的元素按照桶的顺序拿出;</li></ul><p>代码实现:</p><pre><code class="java">public class CountSort {    public static void main(String[] args) {        int[] arr = {2, 4, 2, 3, 7, 1, 1, 1, 0, 5, 6, 9, 8, 7, 4, 0, 9};        int[] result = sort(arr);        System.out.println(Arrays.toString(result));    }    static int[] sort(int[] arr){        //新建一个数组用来存放最终的结果        int[] result = new int[arr.length];        //10个桶        int[] count = new int[10];        //计数,计算每个桶中有多少个数字        for (int i = 0; i &lt; arr.length; i++) {            count[arr[i]]++;        }        System.out.println(Arrays.toString(count));        //累加数组,得到该桶的最后一个数字在最终数组中排在第几位的数字        for (int i = 1; i &lt; count.length; i++) {            count[i] = count[i] + count[i-1];        }        System.out.println(Arrays.toString(count));        //倒序迭代,将待排数字拿出放入累加数组中,得到结果数组中的位置,放入(建议拿出笔来算算)        for (int i = arr.length-1; i &gt;= 0; i--) {            result[--count[arr[i]]] = arr[i];        }        return result;    }}</code></pre><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9mdW5nbm90bC1pbWcub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS8lRTYlQTElQjYlRTYlOEUlOTIlRTUlQkElOEYvUmFkaXhTb3J0LmdpZg" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><ul><li>算法思想:多关键字排序;</li><li>同样,将待排数字依据该数字的个位,十位.百位,千位分别放入桶中;</li></ul><p>代码实现:</p><pre><code class="java">public class RadixSort {    public static void main(String[] args) {        int[] arr = {421, 240, 225, 532, 305, 430, 124};        int[] result = sort(arr);        System.out.println(Arrays.toString(result));    }    public static int[] sort(int[] arr){        int[] result = new int[arr.length];        int[] count = new int[10];        for (int i = 0; i &lt; 3; i++) {            int division = (int) Math.pow(10, i);            System.out.println(division);            //得到余数            for (int j = 0; j &lt; arr.length; j++) {                int num = arr[j]/division % 10;                System.out.print(num + &quot; &quot;);                count[num]++;            }            System.out.println();            System.out.println(Arrays.toString(count));            for (int m = 1; m &lt; count.length; m++) {                count[m] = count[m] + count[m-1];            }            System.out.println(Arrays.toString(count));            for (int n = arr.length-1; n &gt;= 0; n--) {                int num = arr[n]/division % 10;                result[--count[num]] = arr[n];            }            System.arraycopy(result, 0, arr, 0, arr.length);            Arrays.fill(count, 0);        }        return result;    }}</code></pre><hr><h1 id="Mamba-Never-Out"><a href="#Mamba-Never-Out" class="headerlink" title="Mamba Never Out"></a>Mamba Never Out</h1><p>R.I.P Mamba<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9mdW5nbm90bC1pbWcub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS8lRTYlQTElQjYlRTYlOEUlOTIlRTUlQkElOEYvS29iZS5qcGc?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    
    <tags>
      
      <tag>桶排序</tag>
      
      <tag>计数排序</tag>
      
      <tag>基数排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArrayList动态扩容及其验证(JDK12源码分析)</title>
    <link href="/2020/01/01/ArrayList%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E6%BF%80%E8%B5%B7%E9%AA%8C%E8%AF%81(JDK12%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90)/"/>
    <url>/2020/01/01/ArrayList%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E6%BF%80%E8%B5%B7%E9%AA%8C%E8%AF%81(JDK12%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90)/</url>
    
    <content type="html"><![CDATA[<h1 id="ArrayList动态扩容-JDK12"><a href="#ArrayList动态扩容-JDK12" class="headerlink" title="ArrayList动态扩容(JDK12)"></a>ArrayList动态扩容(JDK12)</h1><p>最近有在温习一下java容器,今天就开始读一下ArrayList的动态扩容</p><h2 id="ArrayList是什么"><a href="#ArrayList是什么" class="headerlink" title="ArrayList是什么?"></a>ArrayList是什么?</h2><blockquote><p>ArrayList叫做动态数组,实现了长度可变的数组, 在内存中分配连续的空间.</p></blockquote><p><strong>优缺点</strong></p><blockquote><p>优点:<br>遍历元素和随机访问元素的效率较高<br>缺点:<br>添加和删除需要大量移动元素,效率低;按照内容查询效率低;</p></blockquote><hr><p>ArrayList是在object包中,继承于Collection与其子类AbstractList的.</p><p>所有<strong>实现了的接口</strong>有:Serializable(序列化), Cloneable(克隆), Iratable(迭代器),Collection(集合), List(列表),RandomAccess(随机存取)<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9mdW5nbm90bC1pbWcub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS9BcnJheUxpc3QlRTUlOEElQTglRTYlODAlODElRTYlODklQTklRTUlQUUlQjkvYXJyYXlsaXN0XzEuanBn?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="ArrayList继承关系"></p><h2 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化:"></a>初始化:</h3><p><strong>三个初始化方法:</strong></p><ul><li>默认构造器</li></ul><pre><code class="java">/**     * Constructs an empty list with an initial capacity of ten.     * (构造一个初始容量为10的空列表)     */    public ArrayList() {        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;    }</code></pre><pre><code class="java">/**     * Shared empty array instance used for default sized empty instances. We     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when     * first element is added.     *(为默认空实例提供的空的数组实例,用来区分EMPTY_ELEMENTDATA,以便了解当添加第一个元素时是如何扩容的)     */     //简而言之就是个空数组    private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};</code></pre><ul><li>用指定的大小来初始化内部的数组</li></ul><pre><code class="java">/**     * Constructs an empty list with the specified initial capacity.     *(用指定的初始容量构造一个空的列表)     * @param  initialCapacity  the initial capacity of the list     * @throws IllegalArgumentException if the specified initial capacity     *         is negative     */    public ArrayList(int initialCapacity) {        if (initialCapacity &gt; 0) {            this.elementData = new Object[initialCapacity];        } else if (initialCapacity == 0) {            this.elementData = EMPTY_ELEMENTDATA;        } else {            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+                                               initialCapacity);        }    }</code></pre><ul><li>用一个ICollection对象来构造，并将该集合的元素添加到ArrayList</li></ul><pre><code class="java">/**     * Constructs a list containing the elements of the specified     * collection, in the order they are returned by the collection&#39;s     * iterator.     * (构造一个包含了该集合的列表,并按照集合的迭代器依次返回)     * @param c the collection whose elements are to be placed into this list     * @throws NullPointerException if the specified collection is null     */    public ArrayList(Collection&lt;? extends E&gt; c) {        //将集合C中的内容转化为数组形式存放        elementData = c.toArray();        if ((size = elementData.length) != 0) {            // defend against c.toArray (incorrectly) not returning Object[]            // (see e.g. https://bugs.openjdk.java.net/browse/JDK-6260652)            if (elementData.getClass() != Object[].class)                elementData = Arrays.copyOf(elementData, size, Object[].class);        } else {            // replace with empty array.            this.elementData = EMPTY_ELEMENTDATA;        }    }</code></pre><blockquote><p><strong>这里这一段可能不易理解</strong></p><pre><code class="java">            // defend against c.toArray (incorrectly) not returning Object[]            // (see e.g. https://bugs.openjdk.java.net/browse/JDK-6260652)            //elementData的对象不等于toArray()方法的运行时对象,保证了这个,再进行拷贝            //否则数组有可能发生错乱            if (elementData.getClass() != Object[].class)                elementData = Arrays.copyOf(elementData, size, Object[].class);-----------------------------------------------------------------------------------------------------------------------------------        /**      toArray()方法        //简而言之意思就是:返回一个数组,这个数组是按照之前的顺序返回得到的     * Returns an array containing all of the elements in this collection.     * If this collection makes any guarantees as to what order its elements     * are returned by its iterator, this method must return the elements in     * the same order. The returned array&#39;s {@linkplain Class#getComponentType     * runtime component type} is {@code Object}.     *     //返回一个运行时组件类型为对象的数组,包含所有该集合中的元素     * @return an array, whose {@linkplain Class#getComponentType runtime component     * type} is {@code Object}, containing all of the elements in this collection     */    Object[] toArray();</code></pre></blockquote><h2 id="容量的变化"><a href="#容量的变化" class="headerlink" title="容量的变化"></a>容量的变化</h2><p>容量的变化是先从创建开始的,然后添加元素,伴随着容量的变化;</p><h3 id="元素的添加"><a href="#元素的添加" class="headerlink" title="元素的添加"></a>元素的添加</h3><pre><code class="java"> /**     * This helper method split out from add(E) to keep method     * bytecode size under 35 (the -XX:MaxInlineSize default value),     * which helps when add(E) is called in a C1-compiled loop.     *(这个辅助方法是从add(E)方法分离而来的,为了保持方法字节码低于35,这将有助于add(E)方法调用C1编译循环)(至于咋优化的咱也不想知道)     */    private void add(E e, Object[] elementData, int s) {        if (s == elementData.length)            elementData = grow();        elementData[s] = e;        size = s + 1;    }    /**     * Appends the specified element to the end of this list.     *(追加指定的元素到列表的末端)     * @param e element to be appended to this list     * @return {@code true} (as specified by {@link Collection#add})     */    public boolean add(E e) {        modCount++;        //此处调用上面的那个方法        add(e, elementData, size);        return true;    }</code></pre><h3 id="元素的扩容"><a href="#元素的扩容" class="headerlink" title="元素的扩容"></a>元素的扩容</h3><pre><code class="java">/**     * Increases the capacity to ensure that it can hold at least the     * number of elements specified by the minimum capacity argument.     *(增加容量来保证至少能够容纳这些元素)     * @param minCapacity the desired minimum capacity     * @throws OutOfMemoryError if minCapacity is less than zero     */    private Object[] grow(int minCapacity) {        return elementData = Arrays.copyOf(elementData,                                           newCapacity(minCapacity));    }    private Object[] grow() {        return grow(size + 1);    }    /**     * Returns a capacity at least as large as the given minimum capacity.     * Returns the current capacity increased by 50% if that suffices.     * Will not return a capacity greater than MAX_ARRAY_SIZE unless     * the given minimum capacity is greater than MAX_ARRAY_SIZE.     *(返回一个至少与给定的最小容量一样大的容量)     *(如果足够的话,返回增加当前容量增加50%的容量)     *(除非给定的(传参传进来的)最小容量比MAX_ARRAY_SIZE的值要大,不然不会返回一个比MAX_ARRAY_SIZE还大的值)     * @param minCapacity the desired minimum capacity     * @throws OutOfMemoryError if minCapacity is less than zero     */    private int newCapacity(int minCapacity) {        // overflow-conscious code        int oldCapacity = elementData.length;        //(oldCapacity &gt;&gt; 1)右移操作,右移一位,二进制数右移一位,左边补0;相当于除以二;        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);        if (newCapacity - minCapacity &lt;= 0) {            if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)                return Math.max(DEFAULT_CAPACITY, minCapacity);            if (minCapacity &lt; 0) // overflow                throw new OutOfMemoryError();            return minCapacity;        }        //三元运算符,(判断表达式)? A : B;加入判断表达式得出为true,则返回A,否则返回B        return (newCapacity - MAX_ARRAY_SIZE &lt;= 0)            ? newCapacity            : hugeCapacity(minCapacity);    }</code></pre><p><strong>再贴出hugeCapacity()方法</strong></p><pre><code class="java">//无需多言,相信大家都看的懂 private static int hugeCapacity(int minCapacity) {        if (minCapacity &lt; 0) // overflow            throw new OutOfMemoryError();        return (minCapacity &gt; MAX_ARRAY_SIZE)            ? Integer.MAX_VALUE            : MAX_ARRAY_SIZE;    }</code></pre><h2 id="调试并总结"><a href="#调试并总结" class="headerlink" title="调试并总结"></a>调试并总结</h2><h3 id="调试代码"><a href="#调试代码" class="headerlink" title="调试代码"></a>调试代码</h3><p>仍然贴代码</p><pre><code class="java">public class test {    public static void main(String[] args) {        ArrayList arrayList = new ArrayList();        System.out.println(getArrayListCapacity(arrayList));        for (int i = 0; i &lt; 5; i++) {            arrayList.add(i);            for (int j = 0; j &lt; 5; j++) {                arrayList.add(j);                //想看到更多的容量值变换,可以将i,j的值变大,并在循环体打印                // System.out.println(getArrayListCapacity(arrayList));            }            System.out.println(getArrayListCapacity(arrayList));        }    }    //利用反射机制获取当前ArrayList对象的容量    public static int getArrayListCapacity(ArrayList arrayList) {        Class&lt;ArrayList&gt; arrayListClass = ArrayList.class;        try {            Field field = arrayListClass.getDeclaredField(&quot;elementData&quot;);            field.setAccessible(true);            Object[] objects = (Object[])field.get(arrayList);            return objects.length;        } catch (NoSuchFieldException e) {            e.printStackTrace();            return -1;        } catch (IllegalAccessException e) {            e.printStackTrace();            return -1;        }    }}</code></pre><blockquote><p>输出内容</p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9mdW5nbm90bC1pbWcub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS9BcnJheUxpc3QlRTUlOEElQTglRTYlODAlODElRTYlODklQTklRTUlQUUlQjkvb3V0UHV0LmpwZw?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>结果也是十分清晰:<br>创建时为0,然后马上给了10的容量值,当容量到达了10后,再次添加到10的1.5倍,一直如此,这就是ArrayList的动态扩容了.</p>]]></content>
    
    
    
    <tags>
      
      <tag>ArrayList</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速搭建个人博客</title>
    <link href="/2019/12/09/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2019/12/09/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>我一直都想拥有一个属于自己的网站,自己的博客;<br>很开心,我做到了,这里就与大家分享一下我的搭建过程;</p></blockquote><ul><li>搭建个人博客大概有以下几个步骤:<ul><li>本地环境配置:安装Node.js,Git,Hexo</li><li>阿里云服配置:域名备案,添加安全组,域名解析</li><li>服务器环境配置:安装Node.js,Git,Nginx,Pm2</li><li>github配置webhooks</li></ul></li></ul><p>注:我的本地环境为Win10,云服务器为Centos7</p><h1 id="本地环境配置"><a href="#本地环境配置" class="headerlink" title="本地环境配置"></a>本地环境配置</h1><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装<a href="https://nodejs.org/zh-cn/docs/" target="_blank" rel="noopener">Node.js</a></h3><p> node.js是一个后端的JavaScript运行环境，拥有它，就可以编写系统级或者服务器端的 Javascript 代码，交给node去解释执行。</p><p> 为什么要装node？Hexo本身就是一个JS框架，里面有很多JS脚本，需要node环境去执行。</p><p>这里使用的是安装nvm管理node版本的方式，所以先安装nvm,nvm是针对node产生的一个版本控制工具，使用它可以下载和切换不同版本的node.<br>npm是一种包管理工具，通过npm可以安装各种在npm上传的工具包。在安装node的时候npm会同时安装。<br>后面会需要使用npm安装如hexo等工具。</p><p> 安装nvm(Node Version Manager)</p><ol><li><a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">下载Windows10版nvm安装版本</a><br>1.1 解压,以管理员身份运行nvm-setup.exe文件<br>1.2 安装过程一路next,但要注意安装路径名不能有中文,否则可能出现一些莫名其妙的错误.<br>1.3 配置npm和node.js的下载源<br>1.3.1 编辑nvm目录下的settings.txt文件,在最后加入如下内容<br><code>node_mirror: https://npm.taobao.org/mirrors/node/</code><br><code>npm_mirror: https://npm.taobao.org/mirrors/npm/</code><br>1.4 安装并配置npm及node.js<br>1.4.1 命令行输入命令:<br><code>nvm v</code> 检查nvm是否安装成功<br>如果出现不是内部或外部命令,检查环境变量<br>在系统变量和用户变量加入NVM_HOME(nvm安装目录)和NVM_SYMLINK(node.js安装目录)<br>安装node <code>nvm install 8.0.0</code><br>使用node <code>nvm use 8.0.0</code>（安装完成之后一定要记得use，此时才会生成nodejs文件夹）<br>检查node和npm: <code>node -v</code> <code>npm -v</code><br>安装多个node版本并切换: <code>nvm list</code> 安装最新的node.js及配套npm<code>nvm install latest</code><br>如果想要切换:<code>nvm use 想要使用的node版本</code></li></ol><ol start="2"><li><p>命令行的形式安装(推荐使用)<br>2.1 安装nvm<br> <code>curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | &gt;&gt; bash</code><br> 安装完之后,重新执行全局变量文件<code>source ~/.bash_profile</code><br> 输入 <code>nvm</code> 能够显示nvm版本或者收到Node Version Manager信息即为安装成功<br> 如果提示找不到nvm命令或者没有.bash_profile文件，可以手动添加环境变量<br> <code>vi ~/.bash_profile</code><br> 把这段内容加到文件中<br> <code>export NVM_DIR=&quot;$HOME/.nvm&quot;</code><br> <code>[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot;</code><br> 再次执行<code>source ~/.bash_profile</code><br> 2.2 通过nvm安装node.js<br> 在安装完毕nvm并配置好环境变量后，就可以通过nvm控制node版本<br> 查看node版本<code>nvm list-remote</code><br> 选择任意版本安装 <code>nvm install v8.11.4</code><br> 查看已经安装的node版本 <code>node list</code><br> 切换想要使用的版本<code>nvm use v8.11.4</code><br> 将此版本设置为默认版本<code>nvm alias default v8.11.4</code><br>验证是否安装成功<code>node --version</code> <code>npm -v</code></p><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p><a href="https://git-scm.com/download/win" target="_blank" rel="noopener">安装地址</a></p><blockquote><p>安装完成后<code>git -version</code>确认</p></blockquote><p><a href="https://help.github.com/cn/github/authenticating-to-github/connecting-to-github-with-ssh" target="_blank" rel="noopener">git ssh配置</a><br>ssh的配置目的是为了之后部署好代码，上传时不需要每次都输入用户名密码</p><p>第一次配置需要你的github用户名和邮箱地址</p><blockquote><p> git config –global user.name “xxxxxx” # 自行替换<br>git config –global user.email “<a href="mailto:xxxxxx@xx.com" target="_blank" rel="noopener">xxxxxx@xx.com</a>“ # 自行替换</p></blockquote><p>执行生成秘钥命令</p><blockquote><p><code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; # 你的 GitHub邮箱地址</code></p></blockquote><p>一路Enterd,看到这个就OK了</p></li></ol><p><img src="https://img-blog.csdnimg.cn/20191209102632616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Z1bmdMaV9ub3RMb3Zl,size_10,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>  此时~/.ssh文件夹下就会生成id_rsa（私有秘钥）和id_rsa.pub（公有密钥），将公钥复制带粘贴板</p><blockquote><p><code>pbcopy &lt; ~/.ssh/id_rsa.pub</code></p></blockquote><p>进入github,settings</p><p><img src="https://img-blog.csdnimg.cn/20191209114839857.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>左侧框选择SSH and GPG keys<br><img src="https://img-blog.csdnimg.cn/20191209103640451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Z1bmdMaV9ub3RMb3Zl,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>new SSH key,Title随意取,将刚刚粘贴的秘钥放入Key中</p><p><img src="https://img-blog.csdnimg.cn/20191209103709903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Z1bmdMaV9ub3RMb3Zl,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>完成后,进入命令行,测试配置是否成功<br><code>ssh -T git@github.com</code></p><blockquote><p>The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.<br>RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.<br>Are you sure you want to continue connecting (yes/no)?</p></blockquote><p>YES<br>Hi xxxxxx! You’ve successfully authenticated, but GitHub does not provide bash access.</p><p>完成配置</p></blockquote><h3 id="新建一个github仓库"><a href="#新建一个github仓库" class="headerlink" title="新建一个github仓库"></a>新建一个github仓库</h3><p>打开github,找到仓库,新建仓库<br> Repository name(仓库名)随便写<br> Description(描述)可写可不写<br>选择public<br>直接Create  repository(创建)</p><p><img src="https://img-blog.csdnimg.cn/20191209115338168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Z1bmdMaV9ub3RMb3Zl,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>此处为SSH地址,待会发布hexo时需要<br><img src="https://img-blog.csdnimg.cn/20191209115730671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Z1bmdMaV9ub3RMb3Zl,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">Hexo</a>安装</h3><p> Hexo是一个博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章生成静态网页,并且有方便的发布系统和各种插件。这里主要是安装hexo-cli及如何生成博客的基本模版，确保安装Hexo时已经安装node和git.</p><h3 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h3><p> 使用npm全局安装hexo-cli</p><blockquote><p><code>sudo npm install -g hexo-cli</code></p></blockquote><p> 验证安装</p><blockquote><p> <code>hexo -v</code></p></blockquote><h3 id="使用Hexo"><a href="#使用Hexo" class="headerlink" title="使用Hexo"></a>使用Hexo</h3><p> 在本地新建一个文件夹(就取个名吧,Blog),当成hexo的代码库<br> 进入文件夹,初始化hexo库,在当前文件夹生成网站所需要的文件</p><blockquote><p><code>hexo -init</code></p></blockquote><p> 安装代码仓库所需要的依赖包</p><blockquote><p><code>npm install</code></p></blockquote><p> 执行命令本地预览页面效果</p><blockquote><p><code>hexo generate #也可简写为hexo g</code><br><code>hexo server  #简写为hexo s</code></p></blockquote><p>打开浏览器,输入<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 打开页面,可以看到一个hexo的模板效果</p><p><img src="https://img-blog.csdnimg.cn/20191209140131277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Z1bmdMaV9ub3RMb3Zl,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>回到命令行,Ctrl+C中断本地服务器,继续操作</p><blockquote><p><code>hexo new post &quot;first blog&quot; # 注意标题中有空格需要用双引号包起来</code></p></blockquote><p>这时候会在source/_post文件夹(存放博客文件)中自动创建了一个first-blog.md文件</p><p>再次用hexo启动本地服务器</p><blockquote><p><code>hexo s</code></p></blockquote><p><img src="https://img-blog.csdnimg.cn/20191209142550714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Z1bmdMaV9ub3RMb3Zl,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>通过对source/_post文件夹中的文件进行修改就能更改博客内容</p><h3 id="配置hexo的发布"><a href="#配置hexo的发布" class="headerlink" title="配置hexo的发布"></a>配置hexo的发布</h3><p>每一次 hexo g 生成代码后,我们需要把它同步到git上,再通过github的webhooks自动同步到服务器</p><p> 安装hexo的git部署插件</p><blockquote><p><code>npm install hexo-deployer-git --save</code></p></blockquote><p>打开项目下的_config.yml文件，该文件是整个站点的配置文件，在文件的最下方，修改deploy配置，这里需要用的之前生成的ssh地址</p><blockquote><p>deploy:<br>type: git<br>repo: <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:your_name/blog-web.git # 替换为刚才新建git代码库的ssh链接<br>branch: master</p></blockquote><p>配置好之后,执行命令,更新代码到github</p><blockquote><p>hexo clean &amp;&amp; hexo g # 清楚本来的打包代码并生成出新的</p><p>hexo d # hexo deploy的简写命令`</p></blockquote><h1 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h1><h3 id="帮助文档"><a href="#帮助文档" class="headerlink" title="帮助文档"></a>帮助文档</h3><p>如果你是小白,一点都不懂云服务器,看下面的链接:</p><blockquote><p>1.<a href="https://help.aliyun.com/document_detail/25422.html?spm=a2c4g.11186623.6.577.2ac41bd9u8CyI8" target="_blank" rel="noopener">云服务器ECS入门</a>    </p><p>2.<a href="https://help.aliyun.com/document_detail/25387.html?spm=a2c4g.11186623.6.833.5ce12677fy0zHK" target="_blank" rel="noopener">安全组</a></p><p>3.<a href="https://help.aliyun.com/product/35473.html?spm=a2c4g.750001.list.87.79717b13JIGLJF" target="_blank" rel="noopener">域名</a></p></blockquote><p>如果以下的操作还有不懂的建议百度一下,这里便不再赘余.</p><p>首先推荐两个实用的Linux远程工具Xshell6,Xftp6</p><p>献上破解版</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/11O0o3Hnu26tgiAs1ZQBe6Q" target="_blank" rel="noopener">https://pan.baidu.com/s/11O0o3Hnu26tgiAs1ZQBe6Q</a><br>提取码：6i44<br>复制这段内容后打开百度网盘手机App，操作更方便哦</p></blockquote><h3 id="Xshell使用方法"><a href="#Xshell使用方法" class="headerlink" title="Xshell使用方法"></a>Xshell使用方法</h3><p>名称随便定,协议SSH,主机就是你的阿里云服务器的公网ip,端口号22</p><p><img src="https://img-blog.csdnimg.cn/20191209152848517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Z1bmdMaV9ub3RMb3Zl,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>用户名root,密码就是你的云服务器实例的实例密码</p><p><img src="https://img-blog.csdnimg.cn/2019120915303111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Z1bmdMaV9ub3RMb3Zl,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>这样就能连接上你的云服务器</p><p><img src="https://img-blog.csdnimg.cn/20191209153502530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Z1bmdMaV9ub3RMb3Zl,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="配置安全组"><a href="#配置安全组" class="headerlink" title="配置安全组"></a>配置安全组</h3><p>到云服务控制中心-&gt;网络与安全-&gt;安全组-&gt;配置规则<br><img src="https://img-blog.csdnimg.cn/20191209160027917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Z1bmdMaV9ub3RMb3Zl,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>如果从来没有配置过的可以选择快速创建规则<br><img src="https://img-blog.csdnimg.cn/20191209160423610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Z1bmdMaV9ub3RMb3Zl,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>加入两个必要的安全组:80/80,443/443,授权对象皆为0.0.0.0/0.<br>还需要添加一个webhooks的端口,随意取一个,就7777吧,配置规则和80/80一样;<br>也就是要添加三个安全组:80/80,443/443,7777/7777,<br><img src="https://img-blog.csdnimg.cn/20191209160703752.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Z1bmdMaV9ub3RMb3Zl,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>域名记得备案<br>域名控制台-&gt;域名列表-&gt;解析</p><p><img src="https://img-blog.csdnimg.cn/20191209161529766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Z1bmdMaV9ub3RMb3Zl,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>添加记录-&gt;</p><p><img src="https://img-blog.csdnimg.cn/20191209161653523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Z1bmdMaV9ub3RMb3Zl,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>域名解析后,可以通过域名登录你的网站,而不是公网IP.</p><h3 id="安装Node-js-1"><a href="#安装Node-js-1" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>进入云服务器<br>安装方法和本地环境配置一样,使用命令行方式<br>通过目录跳转到上面的教程</p><h3 id="安装Git-1"><a href="#安装Git-1" class="headerlink" title="安装Git"></a>安装Git</h3><p>安装命令</p><blockquote><p><code>sudo yum install git</code></p></blockquote><p> 查看版本确认安装成功</p><blockquote><p><code>git --version</code></p></blockquote><p>ssh配置</p><blockquote><p><code>git config --global user.name &quot;xxxxxx&quot; # 自行替换</code><br><code>git config --global user.email &quot;xxxxxx@xx.com&quot; # 自行替换</code></p></blockquote><p>执行生成命令秘钥</p><blockquote><p><code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; # 替需要换为你的 GitHub 电子邮件地址</code></p></blockquote><p>一路Enter到成功</p><p>此时~/.ssh文件夹下就会生成id_rsa（私有秘钥）和id_rsa.pub（公有密钥），将公钥复制带粘贴板</p><blockquote><p><code>cd ~/.ssh</code><br><code>cat id_rsa.pub</code></p></blockquote><p>登录github网站-&gt;头像settings-&gt;SSH and GPG keys-&gt;New SSH key-&gt;将粘贴板上的秘钥粘贴上一个新的key(注意区分本地和服务器的SSH key)</p><p>进入服务器端,将github上的代码放入服务器,输入命令行</p><blockquote><p><code>cd /</code><br><code>mkdir www # 用于存放业务代码</code><br><code>cd www</code><br><code>mkdir myBlog # 用于存放前端代码</code><br><code>cd myBlog</code><br><code>git clone git@github.com:yourname/blog-web.git # 自行替换为用于存放博客代码的仓库ssh地址</code></p></blockquote><p>现在，我们完成了git的安装及代码库的部署，但是现在代码只是暂时同步了当前仓库的最新内容，但是如果有人在本地推送新的代码上去，服务端需要重新拉取代码</p><blockquote><p><code>git pull # git代码拉取命令</code></p></blockquote><h3 id="安装及配置Nginx"><a href="#安装及配置Nginx" class="headerlink" title="安装及配置Nginx"></a>安装及配置Nginx</h3><p><a href="http://www.nginx.cn/nginxchswhyuseit" target="_blank" rel="noopener">何为nginx?</a><br>这里使用Nginx就是为了配置反向代理，实现页面访问。</p><p>安装CentOS 7 EPEL存储库，EPEL存储库相当于为系统安装一个第三方包源，其中会有一些常用的工具包</p><blockquote><p> <code>sudo yum install epel-release</code></p></blockquote><p>安装nginx</p><blockquote><p><code>sudo yum install nginx</code></p></blockquote><p> YES至安装成功</p><p>启动Nginx</p><blockquote><p><code>sudo systemctl start nginx</code></p></blockquote><p>设置系统自启nginx</p><blockquote><p><code>sudo systemctl enable nginx</code></p></blockquote><ul><li>配置nginx,让你的域名直接访问到服务器博客代码,显示博客页面<ul><li>找到nginx配置文件,默认在 /etc/nginx/nginx.conf</li></ul></li><li>开始修改配置文件<blockquote><p><code>vi /etc/nginx/nginx.conf # nginx的配置文件路径</code></p></blockquote></li></ul><blockquote><p><code>server {</code><br>       <code>listen       80;</code><br>        <code>server_name  www.baidu.com; # 购买的域名</code><br>      <code>root /www/myBlog/blog-web; # 在服务端的代码路径</code><br>      <code>include /etc/nginx/default.d/*.conf;</code><br>       <code>location / {</code><br>          <code>root /www/myBlog/blog-web;</code><br>          <code>index index.jsp index.html index.htm;</code><br>       <code>}</code><br>   <code>}</code></p></blockquote><p>不会用vim编辑器?<br><a href="https://blog.csdn.net/FungLi_notLove/article/details/81489968" target="_blank" rel="noopener">vim基本用法</a></p><p>重启Nginx</p><blockquote><p><code>systemctl restart nginx</code></p></blockquote><p>完成这些配置后,打开浏览器,输入你的域名,就能浏览你的博客页面了</p><h3 id="安装pm2"><a href="#安装pm2" class="headerlink" title="安装pm2"></a>安装pm2</h3><p><a href="https://pm2.keymetrics.io/docs/usage/quick-start/" target="_blank" rel="noopener">pm2</a>是node的守护进程管理器,安装pm2可以在使用webhooks时创建的服务进行维护<br>安装</p><blockquote><p><code>npm install -g pm2 # npm 在装node时已经自动安装</code><br><code>pm2 -v # 查看pm2版本</code></p></blockquote><p>pm2常用命令</p><blockquote><p>pm2 start <path> # 执行对应路径脚本<br>pm2 list # 查看看起的进程列表<br>pm2 restart &lt;name|id&gt; # 重启对应进程<br>pm2 delete &lt;name|id|’all’&gt; # 删除对应的进程 all是全部<br>pm2 logs # 查看进程打印日志<br>pm2 monit # 监控每个 node 进程的 cpu 和内存使用情况</p></blockquote><h1 id="配置仓库webhooks"><a href="#配置仓库webhooks" class="headerlink" title="配置仓库webhooks"></a>配置仓库webhooks</h1><p><a href="https://developer.github.com/webhooks/" target="_blank" rel="noopener">git webhooks</a>能够实时的将变化的代码提交到服务器</p><p> 打开GitHub仓库-&gt;Settings<br><img src="https://img-blog.csdnimg.cn/20191209183652858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Z1bmdMaV9ub3RMb3Zl,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>Webhooks-&gt;右上角add webhook<br><img src="https://img-blog.csdnimg.cn/2019120918372378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Z1bmdMaV9ub3RMb3Zl,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>URL:http://你的公网ip:7777/<br>Content type: application/json<br>Secret:自己的webhook密码(后面要用到)<br>选择Just the push event.<br>Add webhook<br><img src="https://img-blog.csdnimg.cn/20191209184626962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Z1bmdMaV9ub3RMb3Zl,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="服务器端口设置监听"><a href="#服务器端口设置监听" class="headerlink" title="服务器端口设置监听"></a>服务器端口设置监听</h3><p>登录服务器<br>创建一个文件夹放置监听服务文件<br><code>cd ~</code><br><code>mkdir ListenWebhooks</code><br><code>vi webhook.js # 写入服务</code><br>将以下代码放入webhook.js文件</p><blockquote><p>const secret = “刚刚设置webhook时的secret密码”;<br>const repo = “/www/myBlog/blog-web”;<br>const http = require(“http”);<br>const crypto = require(“crypto”);<br>const exec = require(‘child_process’).exec;<br>http.createServer(function (req, res) {<br>    req.on(‘data’, function(chunk) {<br>        let sig = “sha1=” + crypto.createHmac(‘sha1’, secret).update(chunk.toString()).digest(‘hex’);<br>        if (req.headers[‘x-hub-signature’] == sig) {<br>          exec(‘cd ‘ + repo + ‘ &amp;&amp; git pull’);<br>        } else {<br>            console.log(‘err:’, ‘signature’, req.headers[‘x-hub-signature’], ‘sig’, sig, ‘time:’, new Date());<br>        });<br>        }<br>    res.end();<br>}).listen(7777);</p></blockquote><p>使用pm2开启服务<br><code>pm2 start ./webhook.js</code><br><code>pm2 list # 查看开启的进程列表</code><br><img src="https://img-blog.csdnimg.cn/20191209192557876.png" srcset="/img/loading.gif" alt="pm2 list"><br>测试webhook<br>进入github,编辑webhook,Redeliver,成功!<br><img src="https://img-blog.csdnimg.cn/20191209192805735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Z1bmdMaV9ub3RMb3Zl,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>所有配置全部完成.</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>一般如果测试webhook成功了,所有步骤也就成功了.</p><ul><li>为了测试效果,可以在本地代码库的source/_post文件夹中随便加入一个md文件</li><li>接下来进入代码库文件夹,当前文件夹启动命令行(右键 git bash here也可以)</li><li>输入命令<code>hexo clean &amp;&amp; hexo g</code></li><li>再输入命令<code>hexo d</code></li><li>浏览器输入域名,博客出现md文件的内容的文章即为设置成功</li></ul><h3 id="最后-为了使我们的博客变得更加好看-我们可以登录hexo寻找适合自己的主题并设置"><a href="#最后-为了使我们的博客变得更加好看-我们可以登录hexo寻找适合自己的主题并设置" class="headerlink" title="最后,为了使我们的博客变得更加好看,我们可以登录hexo寻找适合自己的主题并设置!"></a>最后,为了使我们的博客变得更加好看,我们可以登录<a href="https://hexo.io/themes/" target="_blank" rel="noopener">hexo</a>寻找适合自己的主题并设置!</h3><p>有任何问题可以联系我或者评论</p>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>阿里云</tag>
      
      <tag>域名</tag>
      
      <tag>hexo</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java希尔排序详解</title>
    <link href="/2019/10/19/Java%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E8%AF%A6%E8%A7%A3/"/>
    <url>/2019/10/19/Java%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>刚接触希尔排序的时候,我是懵的,因为在学校根本没有学过希尔排序啊!</p><p>查询资料:希尔排序是插入排序的升级版;</p><p>从维基百科截取的Java实现希尔排序的代码</p><pre><code class="java">public static void shellSort(int[] arr) {        int length = arr.length;        int temp;        for (int step = length / 2; step &gt;= 1; step /= 2) {            for (int i = step; i &lt; length; i++) {                temp = arr[i];                int j = i - step;                while (j &gt;= 0 &amp;&amp; arr[j] &gt; temp) {                    arr[j + step] = arr[j];                    j -= step;                }                arr[j + step] = temp;            }        }    }</code></pre><p>我们来简单的试一下:</p><pre><code class="java">public class ShellSortFromWiki{  public static void main(String[] args){    int[] a = {4, 9, 11, 3, 8, 6, 2, 7, 13, 1, 12, 5, 10};    shellSort(a);    print(a);  }  public static void shellSort(int[] arr) {        int length = arr.length;    //获取数组的长度        int temp;                   //临时变量temp        // step是每个区域的数值的个数,当每个区域排序到不能再继续往下排的时候;        // 将区域再次变小,这里是 step /= 2,将每个区域再分一半        for (int step = length / 2; step &gt;= 1; step /= 2) {            for (int i = step; i &lt; length; i++) {                temp = arr[i];                int j = i - step;                while (j &gt;= 0 &amp;&amp; arr[j] &gt; temp) {                    arr[j + step] = arr[j];                    j -= step;                }                arr[j + step] = temp;            }        }    }    static void print(int[] a){      for (int i = 0; i &lt; a.length; i++) {        System.out.print(a[i] + &quot; &quot;);      }    }}</code></pre><p>打印:</p><p>对以上代码稍加修改,打印出每一次排序的过程</p><pre><code class="java">2 9 11 3 8 6 4 7 13 1 12 5 102 7 11 3 8 6 4 9 13 1 12 5 102 7 11 3 8 6 4 9 13 1 12 5 102 7 11 1 8 6 4 9 13 3 12 5 102 7 11 1 8 6 4 9 13 3 12 5 102 7 11 1 8 5 4 9 13 3 12 6 102 7 11 1 8 5 4 9 13 3 12 6 101 7 11 2 8 5 4 9 13 3 12 6 101 7 11 2 8 5 4 9 13 3 12 6 101 7 5 2 8 11 4 9 13 3 12 6 101 7 5 2 8 11 4 9 13 3 12 6 101 7 5 2 8 11 4 9 13 3 12 6 101 7 5 2 8 11 4 9 13 3 12 6 101 7 5 2 8 11 3 9 13 4 12 6 101 7 5 2 8 11 3 9 13 4 12 6 101 7 5 2 8 6 3 9 11 4 12 13 101 7 5 2 8 6 3 9 11 4 12 13 101 7 5 2 8 6 3 9 11 4 12 13 101 5 7 2 8 6 3 9 11 4 12 13 101 2 5 7 8 6 3 9 11 4 12 13 101 2 5 7 8 6 3 9 11 4 12 13 101 2 5 6 7 8 3 9 11 4 12 13 101 2 3 5 6 7 8 9 11 4 12 13 101 2 3 5 6 7 8 9 11 4 12 13 101 2 3 5 6 7 8 9 11 4 12 13 101 2 3 4 5 6 7 8 9 11 12 13 101 2 3 4 5 6 7 8 9 11 12 13 101 2 3 4 5 6 7 8 9 11 12 13 101 2 3 4 5 6 7 8 9 10 11 12 131 2 3 4 5 6 7 8 9 10 11 12 13</code></pre><p>总共30行数据,减去最后一行打印,总共29条;</p><h3 id="排序方式"><a href="#排序方式" class="headerlink" title="排序方式:"></a>排序方式:</h3><blockquote><p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）.</p></blockquote><blockquote><p>注意:如果你看这些文字实在是看不懂,建议拿出纸笔,一步一步算(小编比较愚钝,就是这么做的);</p></blockquote><blockquote><p>这里维基百科提供的代码是根据数组的长度除以2[for (int step = length / 2; step &gt;= 1; step /= 2)];</p></blockquote><p><strong>但这并不是最佳的解决方法</strong></p><p><em>我们来比较一下相同的数组排序次数的差别:</em></p><p>插入排序:38次</p><p>二分希尔排序:29次</p><p>knuth希尔排序:21次</p><p>明显是knuth希尔排序更快,下面介绍一下knuth希尔排序算法:</p><pre><code class="java">public static void sort(int[] arr) {        int h = 1;        while(h &lt;= arr.length /3 ) {            h = h*3 + 1;        }        for(int gap = h; gap &gt; 0; gap = (gap-1)/3) {            for(int i=gap; i&lt;arr.length; i++) {                for(int j=i; j&gt;gap-1; j-=gap) {                    if(arr[j] &lt; arr[j-gap]) {                        swap(arr, j, j-gap);                    }                }            }        }    }</code></pre><h2 id="几种常见的Gap序列"><a href="#几种常见的Gap序列" class="headerlink" title="几种常见的Gap序列:"></a>几种常见的Gap序列:</h2><ul><li>希尔原本的Gap：N/2、N/4、…1(反复除以2)</li><li>Hibbard的Gap：1、3、7、…、2k-1（k表示第几个gap）</li><li>Knuth的Gap: 1、4、13、…、(3k -1) / 2（k表示第几个gap） 4）Sedgewick的Gap: 1、5、19、41、109、…</li></ul><p>看不懂?!</p><p><strong>拿出笔来算 !!</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程与高并发之Volatile关键字</title>
    <link href="/2019/09/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B9%8BVolatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2019/09/10/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B9%8BVolatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p>﻿</p><h1 id="多线程高并发之Volatile关键字"><a href="#多线程高并发之Volatile关键字" class="headerlink" title="多线程高并发之Volatile关键字"></a>多线程高并发之Volatile关键字</h1><h2 id="Volatile关键字"><a href="#Volatile关键字" class="headerlink" title="Volatile关键字"></a>Volatile关键字</h2><p>这里先介绍一下Volatile的意思，话不多说，上翻译</p><p><strong>Volatile</strong>     &nbsp; &nbsp;      [ˈvɒlətaɪl]          &nbsp;  &nbsp;          adj.<br>易变的;无定性的;无常性的;可能急剧波动的;不稳定的;易恶化的;易挥发的;</p><p>话不多说，进入主题</p><ul><li>首先，Volatile是Java语言中的一个<strong>关键字</strong>（在其它编程语言中也有，如C++、C语言都有）。</li><li>简单地说，volatile关键字能使一个变量在多个线程间可见</li><li>volatile的两个作用：1.保证线程的可见性    2.禁止指令重排序</li></ul><h2 id="Volatile的作用"><a href="#Volatile的作用" class="headerlink" title="Volatile的作用"></a>Volatile的作用</h2><h3 id="保证线程可见性"><a href="#保证线程可见性" class="headerlink" title="保证线程可见性"></a>保证线程可见性</h3><p>Java中拥有堆内存，多线程中，线程共享<strong>堆内存</strong>，每个线程也拥有自己的<strong>工作内存</strong>；当某个线程访问并视图修改共享内存中某变量的时候，会将这个变量的值拷贝一份到该线程的私有工作内存；变量值在私有工作内存中改变后，然后写回共享内存，至于什么时候检查新的值，不好控制。</p><pre><code class="java">public class T01_HelloVolatile {    /*volatile*/ boolean running = true; //对比一下有无volatile的情况下，整个程序运行结果的区别    void m() {        System.out.println(&quot;m start&quot;);        while(running) {        }        System.out.println(&quot;m end!&quot;);    }    public static void main(String[] args) {        T01_HelloVolatile t = new T01_HelloVolatile();        new Thread(t::m, &quot;t1&quot;).start();        try {            TimeUnit.SECONDS.sleep(1);        } catch (InterruptedException e) {            e.printStackTrace();        }        t.running = false;    }}</code></pre><h3 id="禁止指令重排序"><a href="#禁止指令重排序" class="headerlink" title="禁止指令重排序"></a>禁止指令重排序</h3><p>指令重排序也是和cpu有关系，每次写都会被线程读到，加了volatile之后。cpu原来执行一条指令的时<br>候它是一步一步的顺序的执行，但是现在的cpu为了提高效率，它会把指令并发的来执行，第一个指令<br>执行到一半的时候第二个指令可能就已经开始执行了，这叫做流水线式的执行。在这种新的架构的设计基础之上呢想充分的利用这一点，那么就要求你的编译器把你的源码编译完的指令之后呢可能进行一个指令的重新排序。</p><pre><code class="java">public class Mgr06 {    private static volatile Mgr06 INSTANCE; //JIT    private Mgr06() {    }    public static Mgr06 getInstance() {        if (INSTANCE == null) {            //双重检查            synchronized (Mgr06.class) {                if(INSTANCE == null) {                    try {                        Thread.sleep(1);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    INSTANCE = new Mgr06();                }            }        }        return INSTANCE;    }    public void m() {        System.out.println(&quot;m&quot;);    }    public static void main(String[] args) {        for(int i=0; i&lt;100; i++) {            new Thread(()-&gt;{                System.out.println(Mgr06.getInstance().hashCode());            }).start();        }    }}</code></pre><p>有一道面试题：<strong>你听说过单例模式吗，单例模式里面有一种叫双重检查的你了解吗，这个单例要不要加volatile？</strong></p><ul><li>答案是<strong>要加的</strong>，我们这个实验很难做出来让它出错的情况，所以以前很多人就不加这个volatile他也不会出问题，不加volatile问题就会出现在指令重排序上；</li><li>第一个线程 INSTANCE = new Mgr06()经过我们的编译器编译之后呢的指令呢是分成三步 。</li><li><ul><li>1.给指令申请内存</li></ul></li><li><ul><li>2.给成员变量初始化</li></ul></li><li><ul><li>3.是把这块内存的内容赋值给INSTANCE。</li></ul></li><li>指令重排序就是指的这里的指令可能会重排序，发生混乱</li><li>因为线程是并发执行的，当另一个线程进入程序后，发现INSTANCE实力已经生成了，就不会进入锁那部分的代码。</li><li>加了volatile会怎么样呢，加了volatile指令重排序就不允许存在了。对这个对象上的指令重排序不允许存在，所以在这个时候一定是保证你初始化完了之后才会赋值给你这个变量。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>多线程与高并发、Volatile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程与高并发之Sleep、Yield、Join方法</title>
    <link href="/2019/09/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B9%8BSleep%E3%80%81Yield%E3%80%81Join%E6%96%B9%E6%B3%95/"/>
    <url>/2019/09/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B9%8BSleep%E3%80%81Yield%E3%80%81Join%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>﻿</p><h1 id="多线程与高并发之Sleep、Yield、Join方法"><a href="#多线程与高并发之Sleep、Yield、Join方法" class="headerlink" title="多线程与高并发之Sleep、Yield、Join方法"></a>多线程与高并发之Sleep、Yield、Join方法</h1><h2 id="Sleep方法"><a href="#Sleep方法" class="headerlink" title="Sleep方法"></a>Sleep方法</h2><p>休眠，让当前线程暂停一段给定时间让其他线程去运行；当给定时间到时，线程自动复活运行；</p><p>测试代码</p><pre><code class="java">static void testSleep(){        new Thread(()-&gt;{            for (int i = 0; i &lt; 100; i++) {                System.out.println(&quot;A&quot; + i);                try{                    //如果运行效果不佳，可以加大休眠的时间                    Thread.sleep(500);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }).start();    }</code></pre><h2 id="Yield方法"><a href="#Yield方法" class="headerlink" title="Yield方法"></a>Yield方法</h2><p>当前线程正执行的时候停止下来进入等待队列等待</p><p>测试代码</p><pre><code class="java">static void testYield(){        Thread t1 = new Thread(()-&gt;{            for (int i = 0; i &lt; 100; i++) {                System.out.println(&quot;A&quot; + i);                if (i%20 == 0){                    Thread.yield();                }            }        });        Thread t2 = new Thread(()-&gt;{            for (int i = 0; i &lt; 100; i++) {                System.out.println(&quot;----------B&quot; + i);                //2的倍数就调用一次yield()方法                if (i%2 == 0){                    Thread.yield();                }            }        });        t1.start();        t2.start();    }</code></pre><p>因为线程在运行中是很快的，线程进入等待队列后又会很快开始运行；<br>我们这里比较两个线程，一个使用Yield()方法次数偏少，一个偏多；<br>for循环100次，足够多的数据才会让测试效果更明显。</p><h2 id="Join方法"><a href="#Join方法" class="headerlink" title="Join方法"></a>Join方法</h2><p>在当前线程中使用其他线程调用Join()方法，当前线程会停下来去运行另一线程；<br>直到线程执行结束，当前线程才会重新执行；</p><p>测试代码</p><pre><code class="java">static void testJoin(){        Thread t1 = new Thread(()-&gt;{            System.out.println(&quot;A线程开始执行&quot;);            for (int i = 0; i &lt; 100; i++) {                System.out.println(&quot;A&quot; + i);                try {                    Thread.sleep(100);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        });        Thread t2 = new Thread(()-&gt;{            System.out.println(&quot;B线程开始执行&quot;);            for (int i = 0; i &lt; 100; i++) {                System.out.println(&quot;B&quot; + i);                try{                    if (i == 10){                        //调用Join()方法                        t1.join();                    }                    Thread.sleep(100);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        });        t1.start();        t2.start();    }</code></pre><p>从结果可以看出，两线程几乎同时启动，然后交替执行，当t2线程调用Join()方法时t2线程停止，直到t2线程结束。</p>]]></content>
    
    
    
    <tags>
      
      <tag>多线程与高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原码,反码,补码详解</title>
    <link href="/2019/09/06/%E5%8E%9F%E7%A0%81,%20%E5%8F%8D%E7%A0%81,%20%E8%A1%A5%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
    <url>/2019/09/06/%E5%8E%9F%E7%A0%81,%20%E5%8F%8D%E7%A0%81,%20%E8%A1%A5%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>﻿首先从<strong>计算机中数值数据的编码和表示</strong>说起</p><h2 id="机器数和真值"><a href="#机器数和真值" class="headerlink" title="机器数和真值"></a>机器数和真值</h2><blockquote><p>实际运算中,数是有正负的,计算机中的数也有正负,通过用一个数的最高位表示符号,如果字长为8位,分别为D7-D0,那么D7就是符号位,0表示正数,1表示负数,D6-D0为数值位;</p></blockquote><blockquote><p>例如:</p><p>11010111 = -87</p></blockquote><p><strong>机器数</strong>:在计算机中,连同符号一起数码化的数,就被称为机器数;如上面的11010111;</p><p><strong>真值</strong>:使用正负号加其绝对值的表示方法的数值;如-87</p><h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><p>将最高位作为符号位（0表示正，1表示负），其它数字位代表数值本身的绝对值的数字;</p><p>如:</p><ul><li>数字6在计算机中原码表示为:     00000110</li><li>数字 -6  在计算机中原码表示为: 10000110</li></ul><blockquote><p>注意:</p><p>以上是在8位计算机中的原码表示，如果在32位或16位计算机中，表示方法是一样的，只是多了几个0而已.</p></blockquote><p>但是原码也是有缺陷的</p><p>有了数值的表示方法就可以对数进行算数运算，但是很快就发现用带符号位的原码进行乘除运算时结果正确，而<strong>在加减运算的时候会出现问题</strong>，如下：</p><pre><code class="java">1 - 1 = 1 + (-1) = 000000001 + 10000001 = 10000010 (-2)显然是错误的</code></pre><p>这时候有人提出了反码</p><h2 id="反码"><a href="#反码" class="headerlink" title="反码:"></a>反码:</h2><p>反码表示规则为：如果是正数，则表示方法和原码一样，如果是负数，则保留符号位1，然后将这个数字的原码按照每位取反，则得到这个数的反码表示形式;</p><p>如:</p><ul><li>数字6在计算机中反码就是他的原码:0000 0110</li><li>数字(-6)在计算机中反码为: 1111 1001</li></ul><p>上文说到了原码的缺陷,在进行减法运算时所得结果与实际结果不相同;</p><p>那么反码就解决了减法运算计算的错误,不过还是存在缺陷,如下:</p><pre><code class="java">1 - 1 = 1 + (-1) = 00000 0001 + 1111 1110 = 1111 1111(-0)有问题</code></pre><p>再看看其他减法是否出错:</p><pre><code class="java">1 - 2 = 1 + (-2) = (-1);0000 0001 + 1111 1101 = 1111 1110(-1)正确</code></pre><p><strong>说明反码在进行减法运算时是正确的,只有在结果为0时可能带有负号</strong>;</p><p>为什么会出现这样的问题呢?因为反码的表示范围为(-127-(-0)) (0-127),总共256个;</p><p>这个问题如何解决?这时候补码出来了!</p><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>补码是计算机表示数据的一般方式(这句话很重要,圈起来,要考)</p><p>其规则为：</p><ul><li>如果是正数，则表示方法和原码一样</li><li>如果是负数，则将数字的反码加上1（相当于将原码数值按位取反然后在对地位加1）;</li></ul><p>负数的补码就是对反码加一，而正数不变，正数的原码反码补码都是一样的;</p><p>再来检验一下上面的问题:</p><pre><code class="java">1 - 1 = 1 + (-1) = 0;0000 0001 + 1111 1111 = 0000 0000;(正确)</code></pre><p>那为什么补码可以这样运算而其他的不行呢,</p><p>在补码中,<strong>用(-128)代替了(-0),所以补码的表示范围变成了(-128- 0-127),共256个</strong>;</p><p><strong>补码的设计目的</strong></p><ul><li><p>使符号位能与有效值部分一起参加运算,从而简化运算规则</p></li><li><p>使减法运算转换为加法运算,进一步简化计算机中运算器的线路设计</p></li></ul><p>这也就是为什么<strong>补码是计算机数据的一般表示方法</strong>的原因之一!</p>]]></content>
    
    
    
    <tags>
      
      <tag>原码</tag>
      
      <tag>补码</tag>
      
      <tag>反码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是区块链？</title>
    <link href="/2019/08/10/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    <url>/2019/08/10/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%BA%E5%9D%97%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是区块链？"><a href="#什么是区块链？" class="headerlink" title="什么是区块链？"></a>什么是区块链？</h2><blockquote><p>区块链技术是利用块链式数据结构来验证与存储数据、利用分布式节点共识算法来生成和更新数据、利用密码学的方式保证数据传输和访问的安全、利用由自动化脚本代码组成的智能合约来编程和操作数据的一种全新的分布式基础架构与计算范式。简单来讲，<br>在区块链系统中， 每过一段时间， 各参与主体产生的交易数据会被打包成一个数据区块， 数据区块按照时间顺序依次排列， 形成数据区块的链条，各参与主体拥有同样的数据链条， 且无法单方面篡改，任何信息的修改只有经过约定比例的主体同意方可进行，并且只能添加新的信息，无法删除或修改旧的信息，从而实现多主体间的信息共享和一致决策，确保各主体身份和主体间交易信息的不可篡改、 公开透明。</p></blockquote><blockquote><p>区块链发展到今天，已经涌现出许多形形色色的区块链项目， 这里梳理了这些区块链项目在技术上的共性： 区块、 账户、 智能合约、 共识， 这 4个主要部分构成了目前的区块链系统的通用模型 。 通过链式结构记录状态的变更历史，每一次变更的状态“快照”都以“区块” 的形式记录；通过非对称密钥对表示参与者身份，以某种形式的状态数据库记录当前的信息， 这部分被称为“账户” ；（注： 以太坊、 Fabric 是账户模型，而比特币是 UTXO 模型） 通过链上编码定义参与者之间的承诺，这部分被称为“智能合约” ； 通过某种算法在多节点之间达成状态一致，这个过程被称为“共识” 。</p></blockquote><h2 id="区块链有哪些特点？"><a href="#区块链有哪些特点？" class="headerlink" title="区块链有哪些特点？"></a>区块链有哪些特点？</h2><p>从技术构成的角度来观察区块链有助于我们揭开它的神秘面纱， 实事求是地分析区块链， 并揭示它的本质特点，理解其价值发挥的内在逻辑。 如前所述， 区块链并不是一个全新的技术， 而是结合了多种现有技术进行的组合式创新，是一种新形式的分布式加密存储系统。<br>区块链本质上是一种健壮和安全的分布式状态机，典型的技术构成包括共识算法、 P2P通讯、密码学、 数据库技术和虚拟机。这也构成了区块链必不可少的 5 项核心能力：</p><blockquote><p>存储数据：源自数据库技术和硬件存储计算能力的发展，随着时间的累积，区块链的大小也在持续上升，成熟的硬件存储计算能力，<br>使得多主体间同时大量存储相同数据成为可能；</p></blockquote><blockquote><p>共有数据：源自共识算法，参与区块链的各个主体通过约定的决策机制自动达成共识， 共享同一份可信的数据账本；</p></blockquote><blockquote><p>分布式：源自 P2P 通讯技术，实现各主体间点对点的信息传输；</p></blockquote><blockquote><p>防篡改与保护隐私：源自密码学运用， 通过公钥私钥、 哈希算法等密码学工具，确保各主体身份和共有信息的安全；</p></blockquote><blockquote><p>数字化合约：源自虚拟机技术，将生成的跨主体的数字化智能合约写入区块链系统，通过预设的触发条件， 驱动数字合约的执行。</p></blockquote><p>3、区块链适合解决哪些问题？<br>通过对比分析、 研究国内外各领域的典型应用案例及相关参考文献，获得了一些有助于在业务中推广及应用区块链的经验， 并推荐具有以下特点的应用场景或问题，应该积极考虑尝试区块链技术：</p><p>业务开展需要进行跨主体协作</p><p>当需要为开展跨主体的业务建设 IT 系统时， 传统的解决方案通常是两种思路。要么建立和运营一个中心化的系统来处理各个参与方的业务需求，业务数据由中心化的组织维护；要么采用 SOA 架构， 由各个参与方发布服务接口，并相互调用，数据仍然维护在各个参与方。如果采用中心化的方案，若是业务的参与方之间是相对独立平等的，要开发建设一个中心化系统是很困难的， 包括协调、 立项、 成本分摊等问题。 如果采用 SOA 的方案， 则技术实践上比较复杂， 技术方案缺少通用性， 难以支持复杂的业务。 此外，从数据的角度来看，无论是中心化的方案还是 SOA， 都难以实现数据防篡改。<br>在业务参与方之间相对独立平等的跨主体业务协作的场景下， 利用区块链的共有数据、防篡改、 分布式和数字化合约的特点， 能够把一些以往需要在业务层面协调解决的问题， 放到技术层面来解决， 使得问题的解决过程更高效、灵活以及更具客观性。</p><p>业务开展需要参与方之间建立低成本信任</p><p>大多数业务开展都需要建立一定的信任基础，尤其是跨主体的场景下。 对信任建立困难、信任维护成本高的应用场景， 区块链可以提供非常有效帮助。</p><h2 id="我们从三个方面来考察区块链如何建立低成本信任："><a href="#我们从三个方面来考察区块链如何建立低成本信任：" class="headerlink" title="我们从三个方面来考察区块链如何建立低成本信任："></a>我们从三个方面来考察区块链如何建立低成本信任：</h2><h2 id="1-数据可信"><a href="#1-数据可信" class="headerlink" title="1. 数据可信"></a>1. 数据可信</h2><blockquote><p>传统的解决方案中，数据通常是以中心化的方式存储，本应共有的业务数据却被强势的参与方持有。<br>这种模式下，数据的可信度是由数据持有者的商业/社会信用来保证的， 只能建立主观的可信，对于一些重要的领域，<br>仍需要付出额外的成本来规避数据被恶意篡改的风险。</p></blockquote><blockquote><p>区块链的解决方案是结合了密码学哈希和数字签名，以区块链条的形式将数据的变更历史按时间先后链在一起，<br>并通过共识协议使得参与的各方都共同拥有这些数据。</p></blockquote><blockquote><p>由于多方分别持有相同的数据副本， 并且数据被签名确认， 并记录数据的“指纹”（哈希值）， 以密码技术保证了数据无法被篡改，<br>数据因此变得可信。</p></blockquote><blockquote><p>区块链使数据持有变得去中心化，以技术手段实现数据客观“可信”。</p></blockquote><h2 id="2-合约履行"><a href="#2-合约履行" class="headerlink" title="2.合约履行"></a>2.合约履行</h2><blockquote><p>通常的合约（或者契约、 协定、合同） 的履行从根本上是由法律来保障的。合约被自觉履行一般都是因为有利益、 道德或法律后果，<br>受许多主观因素影响。 商业活动中为了防止违约、或对违约进行追索， 需要付出高昂的成本（担保、保险、律师费、漫长司法程序等等）。</p></blockquote><blockquote><p>区块链智能合约的本质是一套数字化形式的契约，由计算机确保严格执行。执行方式上，<br>通常的合约是事后以人的主观意愿来执行；而智能合约是在触发条件被满足后，由计算机程序来保证合约及时地执行，具有客观性。</p></blockquote><blockquote><p>我们把资产数字化到区块链或与区块链锚定，<br>采用智能合约来描述对资产关系的承诺，同时智能合约的执行过程和结果被区块链严格记录，这样便可以降低履约成本和确保高效履约。</p></blockquote><blockquote><p>区块链智能合约带来的是“契约” 的一种新的更精确的表示形式， 以及一种更客观、<br>更严格的执行方式。由于契约是我们社会活动的基础，因此这种变化将会带来更广泛的社会影响。</p></blockquote><h2 id="3-历史可证明"><a href="#3-历史可证明" class="headerlink" title="3.历史可证明"></a>3.历史可证明</h2><blockquote><p>区块链固化了交易历史，并提供对交易历史的追溯查询，保证交易的不可篡改和不可抵赖。</p></blockquote><blockquote><p>如果某个事件发生时，这个事件连同时间戳一起被记录到区块链中，将来就可以通过区块链证明这件事确实在这个时间发生过。因此区块链为参与交易的各方保留了可信的历史记录。</p></blockquote><blockquote><p>业务过程存在长交易、 长周期链条</p></blockquote><blockquote><p>业务在多主体间流转时， 难以确定间接主体的真实性和有效性，同时由于多主体间的业务隔离， 难以延伸出多级业务。区块链从技术上保证整个长交易、<br>长周期链条的各参与主体身份真实，数据可信， 实现信用的多级传递， 促进业务链条扁平化，提升业务效率。</p></blockquote><blockquote><p>比特币作为区块链技术的一种典型应用， 在交易市场上市值已达千亿美元，这样的一个高市值系统却是以开源的方式在公共网络上运行了多年，<br>表现出了良好的安全性和健壮性。比特币系统的表现揭示了一个重要事实——以客观区块链技术为手段可以直接建立信任， 而不需中介背书。</p></blockquote><blockquote><p>如果我们把区块链技术推广运用到更广泛的产业、金融、 公共服务等场景， 将使社会的生产分工方式产生巨大变化，这些变化包括:</p></blockquote><ul><li>商业交易过程更容易达成信任， 从而降低风险， 使交易更具确定性；</li><li>商业交易中间环节被缩减， 多方交易可直接达成；</li><li>传统中介的中心化的服务模式将发生巨变。</li></ul><blockquote><p>这种影响目前已经逐渐显现， 随着区块链的逐渐成熟和应用的不断丰富，这种影响力将会像蝴蝶效应一般逐步放大和深入到整个社会，<br>推动去中心化或多中心化主体间的高效协同和共识决策。 人类因掌握“工具” 而发展文明，我们相信区块链是一种新的“工具”<br>，最终将促进人类社会的进步发展。</p></blockquote><h2 id="区块链发展面临的挑战"><a href="#区块链发展面临的挑战" class="headerlink" title="区块链发展面临的挑战"></a>区块链发展面临的挑战</h2><blockquote><p>目前人们已经广泛认识到区块链巨大的应用价值，但是区块链的技术发展却还没有到达成熟阶段， 尤其在企业级应用方面， 区块链的交易并发能力、<br>数据存储能力、通用性、 功能完备性、 易用性都还存在明显不足。</p></blockquote><h2 id="1-交易并发能力"><a href="#1-交易并发能力" class="headerlink" title="1.交易并发能力"></a>1.交易并发能力</h2><blockquote><p>目前开源的区块链系统的高并发交易能力普遍不高， 其中，共识算法是制约性能的重要方面。在区块链中使用的典型共识算法主要有： PoW、 PoS、<br>DPoS、 PBFT 等。 制约性能的另一个重要因素是账本结构。 目前典型的区块链账本设计为区块的单链结构，<br>意味着从全局来看所有的交易都只能顺序地被处理。 由于交易处理缺少并行度，因而难以获得接近于传统中心化系统的性能表现。<br>企业场景下的交易并发量通常要求在每秒处理数百至数千笔以上的交易，<br>远高于目前包括公有链、联盟链在内的典型区块链的表现，而且还要求区块链的性能表现可以随着业务规模的增长而动态伸缩。 因此，<br>现实和目标之间存在数量级的差别， 需要持续优化和提升区块链系统高并发交易性能。</p></blockquote><h2 id="2-数据存储能力"><a href="#2-数据存储能力" class="headerlink" title="2.数据存储能力"></a>2.数据存储能力</h2><blockquote><p>在数据存储能力方面，由于区块链的数据只有追加而没有移除，数据只增不减， 随着时间推移，<br>区块链系统对数据存储大小的需要也只能持续地增大，在处理企业数据时这一趋势增长更甚。 不同于公链数字货币的主要内容是“账户余额” ，<br>企业场景下的数据包含结构化和非结构化数据，数据量十分庞大。以电商供应链为例， 主要电商入口的每日数据记录条数通常都在千万级以上，<br>如再沿着供应链条进一步展开时，每延伸一级数据量都会进一步放大。<br>目前典型的区块链系统在实现对账本数据的存储时，典型的实现方式是基于文件系统或者简单的 KV 数据库存储，<br>没有采用分布式存储的设计，因而数据存储能力与实际需要之间也存在较大的差距， 需要探索更为有效的大数据存储方式。</p></blockquote><h2 id="3-通用性"><a href="#3-通用性" class="headerlink" title="3.通用性"></a>3.通用性</h2><blockquote><p>区块链需要适应多样化的业务需求，满足跨企业的业务链条上的数据共享，这意味着区块链对数据的记录方式要有足够的通用和标准，才能表示各种结构化和非结构化的信息，并能够满足随着业务范围拓展所需的跨链要求。<br>目前市面上的区块链系统大多采用特定的共识算法、 加密算法、 账户模型、 账本模型、存储类型，缺少可插拔能力， 无法适应不同场景要求。</p></blockquote><h2 id="4-功能完备性"><a href="#4-功能完备性" class="headerlink" title="4.功能完备性"></a>4.功能完备性</h2><blockquote><p>纵观现有区块链平台， 模型抽象单一， 难以适应业务系统快速开发的要求。 另外， 缺少对企业应用中常见的一些功能的支持，例如用户认证、<br>多级授权等。 再者，涉及到企业业务协作时， 跨企业的事件通知机制显得尤为重要，但少有区块链平台支持。</p></blockquote><h2 id="5-易用性"><a href="#5-易用性" class="headerlink" title="5.易用性"></a>5.易用性</h2><blockquote><p>区块链是由多种技术构成的，导致学习成本高、 实施难度大、人才稀缺。如何让用户快速理解区块链，低成本学习区块链，并将区块链技术快速应用到自身的业务中去，目前来看有很大的挑战。区块链技术需要降低学习和使用门槛，支持快速实施部署，提供贴近业务的接口，推广使用。</p></blockquote><blockquote><p>从比特币的提出到今天为止， 人们尝试了非常多样化的应用场景。 最初是币（coin）的应用，各种数字货币的出现和热炒引起了广泛关注和讨论。人们发现，作为比特币底层技术的区块链可以用来解决现有业务的一些痛点， 创新业务模式，于是金融和产业领域开始形成一些组织联盟， 如 R3、 Hyperledger 等。 技术圈也逐渐将更多的关注从“币” 转到了区块链的企业级应用。</p></blockquote><blockquote><p>人们在许多领域进行了广泛的尝试， 例如供应链管理， 互联网金融，证券和银行业务，贸易融资，保险，医疗健康， 资产管理，数字版权保护，公益慈善，政府公共服务， 监管合规性与审计，游戏，公益等等。但是，目前已经成功落地的区块链应用比较少，无论是技术还是业务都还处在摸索阶段。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>区块链</tag>
      
      <tag>比特币</tag>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之单例模式</title>
    <link href="/2019/08/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2019/08/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>单例模式（Singleton Pattern）</strong> 是一个比较简单的设计模式，其定义为：</p><ul><li>Ensure a class has only one instance, and provide a global point of access to it.（确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。）。</li><li>Singleton类称为单例类，通过使用private的构造函数确保了在一个应用中只产生一个实例，并且是自行实例化的（在Singleton中自己使用new Singleton()）。</li></ul><h2 id="单例模式六种形式"><a href="#单例模式六种形式" class="headerlink" title="单例模式六种形式"></a>单例模式六种形式</h2><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><pre><code class="java">/* * 类加载到内存后，就实例化一个单例，JVM保证线程安全 * 简单实用，推荐使用！ * 唯一缺点：不管用到与否，类装载时就完成实例化*/public class Mgr01 {    private static final Mgr01 INSTANCE = new Mgr01();    private Mgr01() {};    public static Mgr01 getInstance() {        return INSTANCE;    }    public void m() {        System.out.println(&quot;m&quot;);    }    public static void main(String[] args) {        Mgr01 m1 = Mgr01.getInstance();        Mgr01 m2 = Mgr01.getInstance();        System.out.println(m1 == m2);    }}</code></pre><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><pre><code class="java">//虽然达到了按需初始化的目的，但却带来线程不安全的问题public class Mgr03 {    private static Mgr03 INSTANCE;    private Mgr03() {    }    public static Mgr03 getInstance() {        if (INSTANCE == null) {            try {                Thread.sleep(1);            } catch (InterruptedException e) {                e.printStackTrace();            }            INSTANCE = new Mgr03();        }        return INSTANCE;    }    public void m() {        System.out.println(&quot;m&quot;);    }    public static void main(String[] args) {        for(int i=0; i&lt;100; i++) {            new Thread(()-&gt;                System.out.println(Mgr03.getInstance().hashCode())            ).start();        }    }}</code></pre><h3 id="懒汉式（加锁）"><a href="#懒汉式（加锁）" class="headerlink" title="懒汉式（加锁）"></a>懒汉式（加锁）</h3><pre><code class="java">/** * 也称懒汉式 * 虽然达到了按需初始化的目的，但却带来线程不安全的问题 * 可以通过synchronized解决，但也带来效率下降 */public class Mgr04 {    private static Mgr04 INSTANCE;    private Mgr04() {    }    public static synchronized Mgr04 getInstance() {        if (INSTANCE == null) {            try {                Thread.sleep(1);            } catch (InterruptedException e) {                e.printStackTrace();            }            INSTANCE = new Mgr04();        }        return INSTANCE;    }    public void m() {        System.out.println(&quot;m&quot;);    }    public static void main(String[] args) {        for(int i=0; i&lt;100; i++) {            new Thread(()-&gt;{                System.out.println(Mgr04.getInstance().hashCode());            }).start();        }    }}</code></pre><h3 id="懒汉式（双重检验）"><a href="#懒汉式（双重检验）" class="headerlink" title="懒汉式（双重检验）"></a>懒汉式（双重检验）</h3><pre><code class="java">/** * 也称懒汉式 * 虽然达到了按需初始化的目的，但却带来线程不安全的问题 * 双重检验 */public class Mgr06 {    private static volatile Mgr06 INSTANCE; //JIT    private Mgr06() {    }    public static Mgr06 getInstance() {        if (INSTANCE == null) {            //双重检查            synchronized (Mgr06.class) {                if(INSTANCE == null) {                    try {                        Thread.sleep(1);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    INSTANCE = new Mgr06();                }            }        }        return INSTANCE;    }    public void m() {        System.out.println(&quot;m&quot;);    }    public static void main(String[] args) {        for(int i=0; i&lt;100; i++) {            new Thread(()-&gt;{                System.out.println(Mgr06.getInstance().hashCode());            }).start();        }    }}</code></pre><h3 id="静态内部类方式"><a href="#静态内部类方式" class="headerlink" title="静态内部类方式"></a>静态内部类方式</h3><pre><code class="java">/**     * 静态内部类方式     * JVM保证单例     * 加载外部类时不会加载内部类，这样可以实现懒加载     */    public class Mgr07 {        private Mgr07() {        }        private static class Mgr07Holder {            private final static Mgr07 INSTANCE = new Mgr07();        }        public static Mgr07 getInstance() {            return Mgr07Holder.INSTANCE;        }        public void m() {            System.out.println(&quot;m&quot;);        }        public static void main(String[] args) {            for(int i=0; i&lt;100; i++) {                new Thread(()-&gt;{                    System.out.println(Mgr07.getInstance().hashCode());                }).start();            }        }}</code></pre><h3 id="枚举类方式"><a href="#枚举类方式" class="headerlink" title="枚举类方式"></a>枚举类方式</h3><p>为什么枚举类实现单例模式会如此简单而且线程安全呢？</p><ul><li><p>反射安全</p></li><li><p>序列化和反序列化安全</p><pre><code class="java">/*** 不仅可以解决线程同步，还可以防止反序列化。*/public enum Mgr08 {  INSTANCE;  public void m() {}  public static void main(String[] args) {      for(int i=0; i&lt;100; i++) {          new Thread(()-&gt;{              System.out.println(Mgr08.INSTANCE.hashCode());          }).start();      }  }}</code></pre></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式、单例模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA快捷键大全</title>
    <link href="/2018/09/12/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/"/>
    <url>/2018/09/12/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Ctrl"><a href="#Ctrl" class="headerlink" title="Ctrl"></a>Ctrl</h2><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Ctrl + F</td><td align="left">在当前文件进行文本查找 （必备）</td></tr><tr><td align="left">Ctrl + R</td><td align="left">在当前文件进行文本替换 （必备）</td></tr><tr><td align="left">Ctrl + Z</td><td align="left">撤销 （必备）</td></tr><tr><td align="left">Ctrl + Y</td><td align="left">删除光标所在行 或 删除选中的行 （必备）</td></tr><tr><td align="left">Ctrl + X</td><td align="left">剪切光标所在行 或 剪切选择内容</td></tr><tr><td align="left">Ctrl + C</td><td align="left">复制光标所在行 或 复制选择内容</td></tr><tr><td align="left">Ctrl + D</td><td align="left">复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备）</td></tr><tr><td align="left">Ctrl + W</td><td align="left">递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 （必备）</td></tr><tr><td align="left">Ctrl + E</td><td align="left">显示最近打开的文件记录列表 （必备）</td></tr><tr><td align="left">Ctrl + N</td><td align="left">根据输入的 类名 查找类文件 （必备）</td></tr><tr><td align="left">Ctrl + G</td><td align="left">在当前文件跳转到指定行处</td></tr><tr><td align="left">Ctrl + J</td><td align="left">插入自定义动态代码模板 （必备）</td></tr><tr><td align="left">Ctrl + P</td><td align="left">方法参数提示显示 （必备）</td></tr><tr><td align="left">Ctrl + Q</td><td align="left">光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容</td></tr><tr><td align="left">Ctrl + U</td><td align="left">前往当前光标所在的方法的父类的方法 / 接口定义 （必备）</td></tr><tr><td align="left">Ctrl + B</td><td align="left">进入光标所在的方法/变量的接口或是定义处，等效于 Ctrl + 左键单击 （必备）</td></tr><tr><td align="left">Ctrl + K</td><td align="left">版本控制提交项目，需要此项目有加入到版本控制才可用</td></tr><tr><td align="left">Ctrl + T</td><td align="left">版本控制更新项目，需要此项目有加入到版本控制才可用</td></tr><tr><td align="left">Ctrl + H</td><td align="left">显示当前类的层次结构</td></tr><tr><td align="left">Ctrl + O</td><td align="left">选择可重写的方法</td></tr><tr><td align="left">Ctrl + I</td><td align="left">选择可继承的方法</td></tr><tr><td align="left">Ctrl + +</td><td align="left">展开代码</td></tr><tr><td align="left">Ctrl + -</td><td align="left">折叠代码</td></tr><tr><td align="left">Ctrl + /</td><td align="left">注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 （必备）</td></tr><tr><td align="left">Ctrl + [</td><td align="left">移动光标到当前所在代码的花括号开始位置</td></tr><tr><td align="left">Ctrl + ]</td><td align="left">移动光标到当前所在代码的花括号结束位置</td></tr><tr><td align="left">Ctrl + F1</td><td align="left">在光标所在的错误代码处显示错误信息 （必备）</td></tr><tr><td align="left">Ctrl + F3</td><td align="left">调转到所选中的词的下一个引用位置 （必备）</td></tr><tr><td align="left">Ctrl + F4</td><td align="left">关闭当前编辑文件</td></tr><tr><td align="left">Ctrl + F8</td><td align="left">在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点</td></tr><tr><td align="left">Ctrl + F9</td><td align="left">执行 Make Project 操作</td></tr><tr><td align="left">Ctrl + F11</td><td align="left">选中文件 / 文件夹，使用助记符设定 / 取消书签 （必备）</td></tr><tr><td align="left">Ctrl + F12</td><td align="left">弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</td></tr><tr><td align="left">Ctrl + Tab</td><td align="left">编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口</td></tr><tr><td align="left">Ctrl + End</td><td align="left">跳到文件尾</td></tr><tr><td align="left">Ctrl + Home</td><td align="left">跳到文件头</td></tr><tr><td align="left">Ctrl + Space</td><td align="left">基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号（必备）</td></tr><tr><td align="left">Ctrl + Delete</td><td align="left">删除光标后面的单词或是中文句 （必备）</td></tr><tr><td align="left">Ctrl + BackSpace</td><td align="left">删除光标前面的单词或是中文句 （必备）</td></tr><tr><td align="left">Ctrl + 1,2,3…9</td><td align="left">定位到对应数值的书签位置 （必备）</td></tr><tr><td align="left">Ctrl + 左键单击</td><td align="left">在打开的文件标题上，弹出该文件路径 （必备）</td></tr><tr><td align="left">Ctrl + 光标定位</td><td align="left">按 Ctrl 不要松开，会显示光标所在的类信息摘要</td></tr><tr><td align="left">Ctrl + 左方向键</td><td align="left">光标跳转到当前单词 / 中文句的左侧开头位置 （必备）</td></tr><tr><td align="left">Ctrl + 右方向键</td><td align="left">光标跳转到当前单词 / 中文句的右侧开头位置 （必备）</td></tr><tr><td align="left">Ctrl + 前方向键</td><td align="left">等效于鼠标滚轮向前效果 （必备）</td></tr><tr><td align="left">Ctrl + 后方向键</td><td align="left">等效于鼠标滚轮向后效果 （必备）</td></tr></tbody></table><h2 id="Alt"><a href="#Alt" class="headerlink" title="Alt"></a>Alt</h2><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Alt + `</td><td align="left">显示版本控制常用操作菜单弹出层 （必备）</td></tr><tr><td align="left">Alt + Q</td><td align="left">弹出一个提示，显示当前类的声明 / 上下文信息</td></tr><tr><td align="left">Alt + F1</td><td align="left">显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择 （必备）</td></tr><tr><td align="left">Alt + F2</td><td align="left">对于前面页面，显示各类浏览器打开目标选择弹出层</td></tr><tr><td align="left">Alt + F3</td><td align="left">选中文本，逐个往下查找相同文本，并高亮显示</td></tr><tr><td align="left">Alt + F7</td><td align="left">查找光标所在的方法 / 变量 / 类被调用的地方</td></tr><tr><td align="left">Alt + F8</td><td align="left">在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果</td></tr><tr><td align="left">Alt + Home</td><td align="left">定位 / 显示到当前文件的 Navigation Bar</td></tr><tr><td align="left">Alt + Enter</td><td align="left">IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 （必备）</td></tr><tr><td align="left">Alt + Insert</td><td align="left">代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等 （必备）</td></tr><tr><td align="left">Alt + 左方向键</td><td align="left">切换当前已打开的窗口中的子视图，比如Debug窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换 （必备）</td></tr><tr><td align="left">Alt + 右方向键</td><td align="left">按切换当前已打开的窗口中的子视图，比如Debug窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换 （必备）</td></tr><tr><td align="left">Alt + 前方向键</td><td align="left">当前光标跳转到当前文件的前一个方法名位置 （必备）</td></tr><tr><td align="left">Alt + 后方向键</td><td align="left">当前光标跳转到当前文件的后一个方法名位置 （必备）</td></tr><tr><td align="left">Alt + 1,2,3…9</td><td align="left">显示对应数值的选项卡，其中 1 是 Project 用得最多 （必备）</td></tr></tbody></table><h2 id="Shift"><a href="#Shift" class="headerlink" title="Shift"></a>Shift</h2><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Shift + F1</td><td align="left">如果有外部文档可以连接外部文档</td></tr><tr><td align="left">Shift + F2</td><td align="left">跳转到上一个高亮错误 或 警告位置</td></tr><tr><td align="left">Shift + F3</td><td align="left">在查找模式下，查找匹配上一个</td></tr><tr><td align="left">Shift + F4</td><td align="left">对当前打开的文件，使用新Windows窗口打开，旧窗口保留</td></tr><tr><td align="left">Shift + F6</td><td align="left">对文件 / 文件夹 重命名</td></tr><tr><td align="left">Shift + F7</td><td align="left">在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</td></tr><tr><td align="left">Shift + F8</td><td align="left">在 Debug 模式下，跳出，表现出来的效果跟 F9 一样</td></tr><tr><td align="left">Shift + F9</td><td align="left">等效于点击工具栏的 Debug 按钮</td></tr><tr><td align="left">Shift + F10</td><td align="left">等效于点击工具栏的 Run 按钮</td></tr><tr><td align="left">Shift + F11</td><td align="left">弹出书签显示层 （必备）</td></tr><tr><td align="left">Shift + Tab</td><td align="left">取消缩进 （必备）</td></tr><tr><td align="left">Shift + ESC</td><td align="left">隐藏当前 或 最后一个激活的工具窗口</td></tr><tr><td align="left">Shift + End</td><td align="left">选中光标到当前行尾位置</td></tr><tr><td align="left">Shift + Home</td><td align="left">选中光标到当前行头位置</td></tr><tr><td align="left">Shift + Enter</td><td align="left">开始新一行。光标所在行下空出一行，光标定位到新行位置 （必备）</td></tr><tr><td align="left">Shift +</td><td align="left">左键单击    在打开的文件名上按此快捷键，可以关闭当前打开文件 （必备）</td></tr><tr><td align="left">Shift +</td><td align="left">滚轮前后滚动    当前文件的横向滚动轴滚动 （必备）</td></tr></tbody></table><h2 id="Ctrl-Alt"><a href="#Ctrl-Alt" class="headerlink" title="Ctrl + Alt"></a>Ctrl + Alt</h2><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Ctrl + Alt + L</td><td align="left">格式化代码，可以对当前文件和整个包目录使用 （必备）</td></tr><tr><td align="left">Ctrl + Alt + O</td><td align="left">优化导入的类，可以对当前文件和整个包目录使用 （必备）</td></tr><tr><td align="left">Ctrl + Alt + I</td><td align="left">光标所在行 或 选中部分进行自动代码缩进，有点类似格式化</td></tr><tr><td align="left">Ctrl + Alt + T</td><td align="left">对选中的代码弹出环绕选项弹出层 （必备）</td></tr><tr><td align="left">Ctrl + Alt + J</td><td align="left">弹出模板选择窗口，将选定的代码加入动态模板中</td></tr><tr><td align="left">Ctrl + Alt + H</td><td align="left">调用层次</td></tr><tr><td align="left">Ctrl + Alt + B</td><td align="left">在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</td></tr><tr><td align="left">Ctrl + Alt + C</td><td align="left">重构-快速提取常量</td></tr><tr><td align="left">Ctrl + Alt + F</td><td align="left">重构-快速提取成员变量</td></tr><tr><td align="left">Ctrl + Alt + V</td><td align="left">重构-快速提取变量</td></tr><tr><td align="left">Ctrl + Alt + Y</td><td align="left">同步、刷新</td></tr><tr><td align="left">Ctrl + Alt + S</td><td align="left">打开 IntelliJ IDEA 系统设置 （必备）</td></tr><tr><td align="left">Ctrl + Alt + F7</td><td align="left">显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来</td></tr><tr><td align="left">Ctrl + Alt + F11</td><td align="left">切换全屏模式</td></tr><tr><td align="left">Ctrl + Alt + Enter</td><td align="left">光标所在行上空出一行，光标定位到新行 （必备）</td></tr><tr><td align="left">Ctrl + Alt + Home</td><td align="left">弹出跟当前文件有关联的文件弹出层</td></tr><tr><td align="left">Ctrl + Alt + Space</td><td align="left">类名自动完成</td></tr><tr><td align="left">Ctrl + Alt + 左方向键</td><td align="left">退回到上一个操作的地方 （必备）</td></tr><tr><td align="left">Ctrl + Alt + 右方向键</td><td align="left">前进到上一个操作的地方 （必备）</td></tr><tr><td align="left">Ctrl + Alt + 前方向键</td><td align="left">在查找模式下，跳到上个查找的文件</td></tr><tr><td align="left">Ctrl + Alt + 后方向键</td><td align="left">在查找模式下，跳到下个查找的文件</td></tr><tr><td align="left">Ctrl + Alt + 右括号（]）</td><td align="left">在打开多个项目的情况下，切换下一个项目窗口</td></tr><tr><td align="left">Ctrl + Alt + 左括号（[）</td><td align="left">在打开多个项目的情况下，切换上一个项目窗口</td></tr></tbody></table><h2 id="Ctrl-Shift"><a href="#Ctrl-Shift" class="headerlink" title="Ctrl + Shift"></a>Ctrl + Shift</h2><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Ctrl + Shift + F</td><td align="left">根据输入内容查找整个项目 或 指定目录内文件 （必备）</td></tr><tr><td align="left">Ctrl + Shift + R</td><td align="left">根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 （必备）</td></tr><tr><td align="left">Ctrl + Shift + J</td><td align="left">自动将下一行合并到当前行末尾 （必备）</td></tr><tr><td align="left">Ctrl + Shift + Z</td><td align="left">取消撤销 （必备）</td></tr><tr><td align="left">Ctrl + Shift + W</td><td align="left">递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备）</td></tr><tr><td align="left">Ctrl + Shift + N</td><td align="left">通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 （必备）</td></tr><tr><td align="left">Ctrl + Shift + U</td><td align="left">对选中的代码进行大 / 小写轮流转换 （必备）</td></tr><tr><td align="left">Ctrl + Shift + T</td><td align="left">对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择 （必备）</td></tr><tr><td align="left">Ctrl + Shift + C</td><td align="left">复制当前文件磁盘路径到剪贴板 （必备）</td></tr><tr><td align="left">Ctrl + Shift + V</td><td align="left">弹出缓存的最近拷贝的内容管理器弹出层</td></tr><tr><td align="left">Ctrl + Shift + E</td><td align="left">显示最近修改的文件列表的弹出层</td></tr><tr><td align="left">Ctrl + Shift + H</td><td align="left">显示方法层次结构</td></tr><tr><td align="left">Ctrl + Shift + B</td><td align="left">跳转到类型声明处 （必备）</td></tr><tr><td align="left">Ctrl + Shift + I</td><td align="left">快速查看光标所在的方法 或 类的定义</td></tr><tr><td align="left">Ctrl + Shift + A</td><td align="left">查找动作 / 设置</td></tr><tr><td align="left">Ctrl + Shift + /</td><td align="left">代码块注释 （必备）</td></tr><tr><td align="left">Ctrl + Shift + [</td><td align="left">选中从光标所在位置到它的顶部中括号位置 （必备）</td></tr><tr><td align="left">Ctrl + Shift + ]</td><td align="left">选中从光标所在位置到它的底部中括号位置 （必备）</td></tr><tr><td align="left">Ctrl + Shift + +</td><td align="left">展开所有代码 （必备）</td></tr><tr><td align="left">Ctrl + Shift + -</td><td align="left">折叠所有代码 （必备）</td></tr><tr><td align="left">Ctrl + Shift + F7</td><td align="left">高亮显示所有该选中文本，按Esc高亮消失 （必备）</td></tr><tr><td align="left">Ctrl + Shift + F8</td><td align="left">在 Debug 模式下，指定断点进入条件</td></tr><tr><td align="left">Ctrl + Shift + F9</td><td align="left">编译选中的文件 / 包 / Module</td></tr><tr><td align="left">Ctrl + Shift + F12</td><td align="left">编辑器最大化 （必备）</td></tr><tr><td align="left">Ctrl + Shift + Space</td><td align="left">智能代码提示</td></tr><tr><td align="left">Ctrl + Shift + Enter</td><td align="left">自动结束代码，行末自动添加分号 （必备）</td></tr><tr><td align="left">Ctrl + Shift + Backspace</td><td align="left">退回到上次修改的地方 （必备）</td></tr><tr><td align="left">Ctrl + Shift + 1,2,3…9</td><td align="left">快速添加指定数值的书签 （必备）</td></tr><tr><td align="left">Ctrl + Shift + 左键单击</td><td align="left">把光标放在某个类变量上，按此快捷键可以直接定位到该类中 （必备）</td></tr><tr><td align="left">Ctrl + Shift + 左方向键</td><td align="left">在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句 （必备）</td></tr><tr><td align="left">Ctrl + Shift + 右方向键</td><td align="left">在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句 （必备）</td></tr><tr><td align="left">Ctrl + Shift + 前方向键</td><td align="left">光标放在方法名上，将方法移动到上一个方法前面，调整方法排序 （必备）</td></tr><tr><td align="left">Ctrl + Shift + 后方向键</td><td align="left">光标放在方法名上，将方法移动到下一个方法前面，调整方法排序 （必备）</td></tr></tbody></table><h2 id="Alt-Shift"><a href="#Alt-Shift" class="headerlink" title="Alt + Shift"></a>Alt + Shift</h2><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Alt + Shift + N</td><td align="left">选择 / 添加 task （必备）</td></tr><tr><td align="left">Alt + Shift + F</td><td align="left">显示添加到收藏夹弹出层 / 添加到收藏夹</td></tr><tr><td align="left">Alt + Shift + C</td><td align="left">查看最近操作项目的变化情况列表</td></tr><tr><td align="left">Alt + Shift + I</td><td align="left">查看项目当前文件</td></tr><tr><td align="left">Alt + Shift + F7</td><td align="left">在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入</td></tr><tr><td align="left">Alt + Shift + F9</td><td align="left">弹出 Debug 的可选择菜单</td></tr><tr><td align="left">Alt + Shift + F10</td><td align="left">弹出 Run 的可选择菜单</td></tr><tr><td align="left">Alt + Shift + 左键双击</td><td align="left">选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句 （必备）</td></tr><tr><td align="left">Alt + Shift + 前方向键</td><td align="left">移动光标所在行向上移动 （必备）</td></tr><tr><td align="left">Alt + Shift + 后方向键</td><td align="left">移动光标所在行向下移动 （必备）</td></tr></tbody></table><h2 id="Ctrl-Shift-Alt"><a href="#Ctrl-Shift-Alt" class="headerlink" title="Ctrl + Shift + Alt"></a>Ctrl + Shift + Alt</h2><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">Ctrl + Shift + Alt + V</td><td align="left">无格式黏贴 （必备）</td></tr><tr><td align="left">Ctrl + Shift + Alt + N</td><td align="left">前往指定的变量 / 方法</td></tr><tr><td align="left">Ctrl + Shift + Alt + S</td><td align="left">打开当前项目设置 （必备）</td></tr><tr><td align="left">Ctrl + Shift + Alt + C</td><td align="left">复制参考信息</td></tr></tbody></table><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table><thead><tr><th align="left">快捷键</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="left">F2</td><td align="left">跳转到下一个高亮错误 或 警告位置 （必备）</td></tr><tr><td align="left">F3</td><td align="left">在查找模式下，定位到下一个匹配处</td></tr><tr><td align="left">F4</td><td align="left">编辑源 （必备）</td></tr><tr><td align="left">F7</td><td align="left">在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</td></tr><tr><td align="left">F8</td><td align="left">在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</td></tr><tr><td align="left">F9</td><td align="left">在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上</td></tr><tr><td align="left">F11</td><td align="left">添加书签 （必备）</td></tr><tr><td align="left">F12</td><td align="left">回到前一个工具窗口 （必备）</td></tr><tr><td align="left">Tab</td><td align="left">缩进 （必备）</td></tr><tr><td align="left">ESC</td><td align="left">从工具窗口进入代码文件窗口 （必备）</td></tr><tr><td align="left">连按两次Shift</td><td align="left">弹出 Search Everywhere 弹出层</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>IDEA</tag>
      
      <tag>快捷键</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VI/VIM的使用</title>
    <link href="/2018/08/07/vi_vim%20%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2018/08/07/vi_vim%20%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="vi-vim-的使用"><a href="#vi-vim-的使用" class="headerlink" title="vi/vim 的使用"></a>vi/vim 的使用</h1><p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式</strong>（Command mode），<strong>输入模式</strong>（Insert mode）和<strong>底线命令模式</strong>（Last line mode）。 这三种模式的作用分别是：</p><h2 id="命令模式："><a href="#命令模式：" class="headerlink" title="命令模式："></a>命令模式：</h2><p>用户刚刚启动 vi/vim，便进入了命令模式。</p><p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p><p>以下是常用的几个命令：</p><ul><li>i 切换到输入模式，以输入字符。</li><li>x 删除当前光标所在处的字符。</li><li>: 切换到底线命令模式，以在最底一行输入命令。<br>若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。</li></ul><p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p><h2 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h2><p>在命令模式下按下i就进入了输入模式。</p><p>在输入模式中，可以使用以下按键：</p><ul><li>字符按键以及Shift组合，输入字符</li><li>Enter，回车键，换行</li><li>Backspace，退格键，删除光标前一个字符</li><li>Delete，删除键，删除光标后一个字符</li><li>方向键，在文本中移动光标</li><li>HOME/END，移动光标到行首/行尾</li><li>Page Up/Page Down，上/下翻页</li><li>Insert，切换光标为输入/替换模式，光标将变成竖线/下划线</li><li>ESC，退出输入模式，切换到命令模式<h2 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h2>在命令模式下按下:（英文冒号）就进入了底线命令模式。</li></ul><p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p><p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p><ul><li>q 退出程序</li><li>w 保存文件<br>按ESC键可随时退出底线命令模式。</li></ul><p>附一张VIM键盘图<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9mdW5nbm90bC1pbWcub3NzLWNuLWhhbmd6aG91LmFsaXl1bmNzLmNvbS92aW1BbmR2aS5wbmc?x-oss-process=image/format,png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p>]]></content>
    
    
    
    <tags>
      
      <tag>VI</tag>
      
      <tag>VIM</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
